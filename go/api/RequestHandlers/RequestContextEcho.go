// //////////////////////////////////////////////////////////////
// RequestContextEcho is the implementation of RequestContext for echo
//
// Created: 2025/12/25 by Chen Ding (Generated by Qwen)
// //////////////////////////////////////////////////////////////

package RequestHandlers

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"time"

	"github.com/chendingplano/shared/go/api/ApiTypes"
	"github.com/chendingplano/shared/go/api/ApiUtils"
	"github.com/chendingplano/shared/go/api/databaseutil"
	"github.com/chendingplano/shared/go/api/sysdatastores"
	middleware "github.com/chendingplano/shared/go/auth-middleware"
	"github.com/google/uuid"
	"github.com/labstack/echo/v4"
	"golang.org/x/crypto/bcrypt"
)

type echoContext struct {
	c echo.Context
}

func NewFromEcho(c echo.Context) RequestContext {
	return &echoContext{c: c}
}

func (e *echoContext) Context() context.Context {
	return e.c.Request().Context()
}

func (e *echoContext) GetRequest() *http.Request {
	return e.c.Request()
}

func (e *echoContext) GetBody() io.ReadCloser {
	return e.c.Request().Body
}

func (e *echoContext) FormValue(name string) string {
	return e.c.FormValue(name)
}

func (e *echoContext) GetCookie(name string) string {
	cookie, err := e.c.Cookie(name)
	if err == nil {
		return cookie.Value
	}
	return ""
}

func (e *echoContext) QueryParam(key string) string {
	return e.c.QueryParam(key)
}

// func (e *echoContext) SetCookie(cookie *http.Cookie) {
func (e *echoContext) SetCookie(session_id string) {
	is_secure := ApiUtils.IsSecure()
	cookie := new(http.Cookie)
	cookie.Name = "session_id"
	cookie.Value = session_id
	cookie.Path = "/"
	cookie.HttpOnly = true
	cookie.Secure = is_secure
	cookie.SameSite = http.SameSiteStrictMode
	e.c.SetCookie(cookie)
}

func (e *echoContext) ReqID() string {
	if id, ok := e.c.Get(EchoReqIDKey).(string); ok && id != "" {
		return id
	}
	// Generate and store
	id := ApiUtils.GenerateRequestID("e")
	e.c.Set(EchoReqIDKey, id)
	return id
}

func (e *echoContext) SetReqID(reqID string) {
	e.c.Set(EchoReqIDKey, reqID)
}

func (e *echoContext) Bind(reqID string, v interface{}) error {
	return e.c.Bind(v)
}

func (e *echoContext) GenerateAuthToken(reqID string, email string) (string, error) {
	// For Echo/PostgreSQL/MySQL, we don't use Pocketbase auth tokens
	// Instead, we return a session-based token or JWT
	// This is a placeholder - implement based on your auth strategy
	token := ApiUtils.GenerateSecureToken(32)
	log.Printf("[req=%s] Generated session token for user %s (SHD_RCE_109)", reqID, email)
	return token, nil
}

func (e *echoContext) UpdatePassword(reqID string, email string, plaintextPassword string) (bool, int, string) {
	// Hash password
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(plaintextPassword), bcrypt.DefaultCost)
	if err != nil {
		error_msg := fmt.Sprintf("failed to hash password, email:%s, err:%v", email, err)
		log.Printf("[req=%s] ***** Alarm:%s (SHD_RCP_210)", reqID, error_msg)

		sysdatastores.AddActivityLog(ApiTypes.ActivityLogDef{
			ActivityName: ApiTypes.ActivityName_Auth,
			ActivityType: ApiTypes.ActivityType_PasswordUpdateFailure,
			AppName:      ApiTypes.AppName_Auth,
			ModuleName:   ApiTypes.ModuleName_EmailAuth,
			ActivityMsg:  &error_msg,
			CallerLoc:    "SHD_RCP_218"})

		return false, http.StatusInternalServerError, error_msg
	}

	err = sysdatastores.UpdatePasswordByEmail(reqID, email, string(hashedPassword))
	if err != nil {
		error_msg := fmt.Sprintf("failed to update password in database, email:%s, err:%v", email, err)
		log.Printf("[req=%s] ***** Alarm:%s (SHD_RCP_230)", reqID, error_msg)

		sysdatastores.AddActivityLog(ApiTypes.ActivityLogDef{
			ActivityName: ApiTypes.ActivityName_Auth,
			ActivityType: ApiTypes.ActivityType_PasswordUpdateFailure,
			AppName:      ApiTypes.AppName_Auth,
			ModuleName:   ApiTypes.ModuleName_EmailAuth,
			ActivityMsg:  &error_msg,
			CallerLoc:    "SHD_RCP_238"})

		return false, http.StatusInternalServerError, error_msg
	}

	return true, 0, ""
}

func (e *echoContext) VerifyUserPassword(reqID string, email, password string) (bool, int, string) {
	user_info, found := e.GetUserInfoByEmail(reqID, email)
	if !found {
		log.Printf("[req=%s] No user found for email (SHD_RCP_110): %s", reqID, email)
		return false, http.StatusNotFound, "email not found (SHD_RCE_131)"
	}

	if user_info.Password == "" {
		home_domain := os.Getenv("APP_DOMAIN_NAME")
		if home_domain == "" {
			error_msg := "missing APP_DOMAIN_NAME env var (SHD_RCP_092)"
			log.Printf("[req=%s] ***** Alarm:%s", reqID, error_msg)
		}
		token := uuid.NewString()
		url := fmt.Sprintf("%s/auth/email/reset?token=%s", home_domain, token)
		error_msg := fmt.Sprintf("user not set password yet, sent reset password email to:%s, email:%s, token:%s",
			email, token, url)

		sysdatastores.AddActivityLog(ApiTypes.ActivityLogDef{
			ActivityName: ApiTypes.ActivityName_Auth,
			ActivityType: ApiTypes.ActivityType_SentEmail,
			AppName:      ApiTypes.AppName_Auth,
			ModuleName:   ApiTypes.ModuleName_EmailAuth,
			ActivityMsg:  &error_msg,
			CallerLoc:    "SHD_RCE_216"})

		e.UpdateTokenByEmail(reqID, email, token)

		subject := "Reset your password"
		body := fmt.Sprintf(`
        	<p>Please click the link below to reset your password:</p>
        	<p><a href="%s">%s</a></p>`, url, url)

		log.Printf("[req=%s] %s (SHD_EML_227)", reqID, error_msg)
		ApiUtils.SendMail(reqID, email, subject, body, "SHD_RCE_154")

		msg := fmt.Sprintf("You have not set the password yet. An email has been sent to your email:%s. "+
			"Please check your email and click the link to set your password (SHD_EML_135)", email)
		return false, http.StatusUnauthorized, msg
	}

	// Hash password
	err := bcrypt.CompareHashAndPassword([]byte(user_info.Password), []byte(password))
	if err != nil {
		error_msg := fmt.Sprintf("invalid password, email:%s", email)
		log.Printf("[req=%s] +++++ Warning:%s (SHD_EML_240)", reqID, error_msg)

		sysdatastores.AddActivityLog(ApiTypes.ActivityLogDef{
			ActivityName: ApiTypes.ActivityName_Auth,
			ActivityType: ApiTypes.ActivityType_InvalidPassword,
			AppName:      ApiTypes.AppName_Auth,
			ModuleName:   ApiTypes.ModuleName_EmailAuth,
			ActivityMsg:  &error_msg,
			CallerLoc:    "SHD_EML_248"})

		return false, http.StatusUnauthorized, error_msg
	}

	return true, 0, ""
}

func (e *echoContext) GetUserInfoByToken(reqID string, token string) (ApiTypes.UserInfo, bool) {
	var user_info ApiTypes.UserInfo
	return user_info, false
}

func (e *echoContext) GetUserInfoByEmail(reqID string, email string) (ApiTypes.UserInfo, bool) {
	user_info, err := sysdatastores.GetUserInfoByEmail(reqID, email)
	if err != nil {
		// Possible reasons:
		// 1. user not found: user not found
		// 2. user pending verify:
		// 3. database error: error: xxx
		// 4. invalid user: (status not active)
		if errors.Is(err, sql.ErrNoRows) {
			// No user found with that email
			log.Printf("[req=%s] No user found for email: %s", reqID, email)
			return user_info, false
		}

		// Real database error
		error_msg := fmt.Sprintf("Database error (SHD_RHD_225):%v, email:%s", err, email)
		log.Printf("[req=%s] ***** Alarm:%s", reqID, error_msg)
		return user_info, false
	}

	return user_info, true
}

func (e *echoContext) SaveSession(
	reqID string,
	login_method string,
	session_id string,
	user_name string,
	user_name_type string,
	user_reg_id string,
	user_email string,
	expiry time.Time) error {
	return sysdatastores.SaveSession(login_method, session_id,
		user_name, user_name_type, user_reg_id,
		user_email, expiry)
}

func (e *echoContext) MarkUserVerified(reqID string, email string) error {
	return sysdatastores.MarkUserVerified(reqID, email)
}

func (e *echoContext) UpdateTokenByEmail(reqID string, email string, token string) error {
	return databaseutil.UpdateVTokenByEmail(ApiTypes.DatabaseInfo.DBType,
		ApiTypes.LibConfig.SystemTableNames.TableNameUsers, email, token)
}

/*
type UserInfo struct {
	UserId          string `json:"user_id"`
	UserName        string `json:"user_name"`
	Password        string `json:"password"`
	UserIdType      string `json:"user_id_type"`
	FirstName       string `json:"firstName"`
	LastName        string `json:"lastName"`
	Email           string `json:"email"`
	UserMobile      string `json:"user_mobile,omitempty"`
	UserAddress     string `json:"user_address"`
	Verified        bool   `json:"verfied"`
	Admin           bool   `json:"admin"`
	EmailVisibility bool   `json:"emailVisibility"`
	AuthType        string `json:"auth_type"`
	UserStatus      string `json:"user_status"`
	Avatar          string `json:"avatar"`
	Locale          string `json:"locale"`
	VToken          string `json:"v_token"`
}
*/

func (e *echoContext) UpsertUser(reqID string,
	user_id_type string,
	user_name string,
	plain_password string,
	user_email string,
	auth_type string,
	status string,
	first_name string,
	last_name string,
	token string,
	avatar string) (ApiTypes.UserInfo, error) {
	// Check if user exists
	user_info, found := e.GetUserInfoByEmail(reqID, user_email)
	var is_dirty bool = false
	if !found {
		is_dirty = true
		user_info.UserName = user_name
		user_info.UserIdType = user_id_type
		user_info.Email = user_email
		user_info.FirstName = first_name
		user_info.LastName = last_name
		user_info.AuthType = auth_type
		user_info.UserStatus = status
		user_info.VToken = token
		if plain_password != "" {
			hashedPwd, _ := bcrypt.GenerateFromPassword([]byte(plain_password), bcrypt.DefaultCost)
			user_info.Password = string(hashedPwd)
		}
	} else {
		// Update existing user info
		if user_name != "" {
			user_info.UserName = user_name
			is_dirty = true
		}
		if user_id_type != "" {
			user_info.UserIdType = user_id_type
			is_dirty = true
		}
		if first_name != "" {
			user_info.FirstName = first_name
			is_dirty = true
		}
		if last_name != "" {
			user_info.LastName = last_name
			is_dirty = true
		}
		if user_email != "" {
			user_info.Email = user_email
			is_dirty = true
		}
		if auth_type != "" {
			user_info.AuthType = auth_type
			is_dirty = true
		}
		if status != "" {
			user_info.UserStatus = status
			is_dirty = true
		}
		if plain_password != "" {
			hashedPwd, _ := bcrypt.GenerateFromPassword([]byte(plain_password), bcrypt.DefaultCost)
			user_info.Password = string(hashedPwd)
			is_dirty = true
		}
		if token != "" {
			user_info.VToken = token
			is_dirty = true
		}
		if avatar != "" {
			user_info.Avatar = avatar
			is_dirty = true
		}
	}

	if !is_dirty {
		log.Printf("[req=%s] No changes for user %s, skip upsert (SHD_RCE_121)", reqID, user_email)
		return user_info, nil
	}

	ok, err := sysdatastores.AddUserNew(reqID, user_info)
	if !ok {
		log_id := sysdatastores.NextActivityLogID()
		error_msg := fmt.Sprintf("Failed creating user (SHD_RCE_123), user_name:%s, email:%s, err:%s, log_id:%d",
			user_info.UserName, user_info.Email, err, log_id)
		log.Printf("[req=%s] ***** Alarm %s (SHD_EML_393)", reqID, error_msg)

		sysdatastores.AddActivityLog(ApiTypes.ActivityLogDef{
			LogID:        log_id,
			ActivityName: ApiTypes.ActivityName_Auth,
			ActivityType: ApiTypes.ActivityType_DatabaseError,
			AppName:      ApiTypes.AppName_Auth,
			ModuleName:   ApiTypes.ModuleName_EmailAuth,
			ActivityMsg:  &error_msg,
			CallerLoc:    "SHD_EML_664"})

		return user_info, fmt.Errorf("%s", error_msg)
	}

	return user_info, nil
}

func (e *echoContext) IsAuthenticated(reqID string, loc string) (ApiTypes.UserInfo, error) {
	var ctx = e.c
	user_info, err := middleware.IsAuthenticated(ctx, "SHD_RHD_008")
	if err != nil {
		log_id := sysdatastores.NextActivityLogID()
		error_msg := fmt.Sprintf("auth failed, err:%v, log_id:%d", err, log_id)
		sysdatastores.AddActivityLog(ApiTypes.ActivityLogDef{
			LogID:        log_id,
			ActivityName: ApiTypes.ActivityName_JimoRequest,
			ActivityType: ApiTypes.ActivityType_AuthFailure,
			AppName:      ApiTypes.AppName_RequestHandler,
			ModuleName:   ApiTypes.ModuleName_RequestHandler,
			ActivityMsg:  &error_msg,
			CallerLoc:    "SHD_RHD_065"})

		log.Printf("[req:%s] %s (SHD_RHD_067)", reqID, error_msg)
		return ApiTypes.UserInfo{}, fmt.Errorf("%s", error_msg)
	}
	return user_info, nil
}

// Private context key (avoids collisions)
var EchoReqIDKey = "echo/reqID"
