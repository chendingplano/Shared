// //////////////////////////////////////////////////////////////
// RequestContextEcho is the implementation of RequestContext for
// Pocketbase.
//
// Created: 2025/12/25 by Chen Ding (Generated by Qwen)
// //////////////////////////////////////////////////////////////

package RequestHandlers

import (
	"context"
	"database/sql"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"log"
	"net/http"
	"path"
	"strings"
	"time"

	"github.com/chendingplano/shared/go/api/ApiTypes"
	"github.com/chendingplano/shared/go/api/ApiUtils"
	"github.com/chendingplano/shared/go/api/sysdatastores"
	"github.com/pocketbase/dbx"
	"github.com/pocketbase/pocketbase/core"
	"github.com/pocketbase/pocketbase/tools/filesystem"
)

type pbContext struct {
	e *core.RequestEvent
}

func NewFromPocket(e *core.RequestEvent) RequestContext {
	return &pbContext{e: e}
}

func (p *pbContext) Context() context.Context {
	return p.e.Request.Context()
}

func (p *pbContext) GetCookie(name string) string {
	cookie, err := p.e.Request.Cookie(name)
	if err == nil {
		return cookie.Value
	}
	return ""
}

func (p *pbContext) FormValue(name string) string {
	return p.e.Request.FormValue(name)
}

func (p *pbContext) SetCookie(token string) {
	// Set the Pocketbase auth cookie manually
	// Pocketbase uses "pb_auth" cookie for authentication
	authCookie := &http.Cookie{
		Name:     "pb_auth",
		Value:    token,
		Path:     "/",
		HttpOnly: true,
		Secure:   ApiUtils.IsSecure(),
		SameSite: http.SameSiteLaxMode,
		MaxAge:   604800, // 7 days (Pocketbase default)
	}
	http.SetCookie(p.e.Response, authCookie)
	log.Printf("Set Pocketbase cookie 'pb_auth':%s (SHD_RCP_068)", token)
}

func (p *pbContext) GetRequest() *http.Request {
	return p.e.Request
}

func (p *pbContext) GetBody() io.ReadCloser {
	return p.e.Request.Body
}

func (p *pbContext) QueryParam(key string) string {
	return p.e.Request.URL.Query().Get(key)
}

func (p *pbContext) UpdateTokenByEmail(
	reqID string,
	email string,
	token string) error {
	// Get the collection
	collection, err := p.e.App.FindCollectionByNameOrId("users")
	if err != nil {
		error_msg := fmt.Sprintf("failed to find users collection (SHD_RCP_104), err:%v", err)
		log.Printf("[req=%s] ***** Alarm:%s", reqID, error_msg)
		return fmt.Errorf("%s", error_msg)
	}

	record, err := p.e.App.FindFirstRecordByFilter(
		collection.Id,
		"email = {:email}",
		dbx.Params{
			"email": email,
		},
	)

	if err != nil {
		error_msg := fmt.Sprintf("failed to find user (SHD_RCP_118), err:%v", err)
		log.Printf("[req=%s] ***** Alarm:%s", reqID, error_msg)
		return fmt.Errorf("%s", error_msg)
	}

	record.Set("tokenKey1", token)
	if err := p.e.App.Save(record); err != nil {
		error_msg := fmt.Sprintf("failed to update user (SHD_RCP_125), err:%v", err)
		log.Printf("[req=%s] ***** Alarm:%s", reqID, error_msg)
		return fmt.Errorf("%s", error_msg)
	}

	return nil
}

func (p *pbContext) MarkUserVerified(reqID string, email string) error {
	// Get the collection
	collection, err := p.e.App.FindCollectionByNameOrId("users")
	if err != nil {
		error_msg := fmt.Sprintf("failed to find users collection (SHD_RCP_421), err:%v", err)
		log.Printf("[req=%s] ***** Alarm:%s", reqID, error_msg)
		return fmt.Errorf("%s", error_msg)
	}

	record, err := p.e.App.FindFirstRecordByFilter(
		collection.Id,
		"email = {:email}",
		dbx.Params{
			"email": email,
		},
	)

	if err != nil {
		error_msg := fmt.Sprintf("failed to find user (SHD_RCP_115), err:%v", err)
		log.Printf("[req=%s] ***** Alarm:%s", reqID, error_msg)
		return fmt.Errorf("%s", error_msg)
	}

	record.Set("verified", true)
	if err := p.e.App.Save(record); err != nil {
		error_msg := fmt.Sprintf("failed to update user (SHD_RCP_122), err:%v", err)
		log.Printf("[req=%s] ***** Alarm:%s", reqID, error_msg)
		return fmt.Errorf("%s", error_msg)
	}

	log.Printf("[req=%s] Successfully marked user as verified (SHD_RCP_149), email:%s", reqID, email)
	return nil
}

func (p *pbContext) GenerateAuthToken(reqID string, email string) (string, error) {
	// Find the auth record by email
	userRecord, err := p.e.App.FindAuthRecordByEmail("users", email)
	if err != nil {
		error_msg := fmt.Sprintf("failed to find user (SHD_RCP_165), email:%s, err:%v", email, err)
		log.Printf("[req=%s] ***** Alarm:%s", reqID, error_msg)
		return "", fmt.Errorf("%s", error_msg)
	}

	// Generate Pocketbase auth token
	token, tokenErr := userRecord.NewAuthToken()
	if tokenErr != nil {
		error_msg := fmt.Sprintf("failed to generate auth token (SHD_RCP_166), email:%s, err:%v", email, tokenErr)
		log.Printf("[req=%s] ***** Alarm:%s", reqID, error_msg)
		return "", fmt.Errorf("%s", error_msg)
	}

	log.Printf("[req=%s] Successfully generated auth token for user %s (SHD_RCP_167)", reqID, email)
	return token, nil
}

func (p *pbContext) UpdatePassword(
	ctx context.Context,
	reqID string,
	email string,
	password string) (bool, int, string) {
	// Get the collection
	log.Printf("[req=%s] Update user password (SHD_RCP_167), email:%s", reqID, email)

	// Get the collection
	collection, err := p.e.App.FindCollectionByNameOrId("users")
	if err != nil {
		error_msg := fmt.Sprintf("Collection not exist (SHD_RCP_173), err:%v", err)
		sysdatastores.AddActivityLog(ApiTypes.ActivityLogDef{
			ActivityName: ApiTypes.ActivityName_Auth,
			ActivityType: ApiTypes.ActivityType_PasswordUpdateFailure,
			AppName:      ApiTypes.AppName_Auth,
			ModuleName:   ApiTypes.ModuleName_EmailAuth,
			ActivityMsg:  &error_msg,
			CallerLoc:    "SHD_RCE_180"})

		return false, http.StatusInternalServerError, error_msg
	}

	record, err := p.e.App.FindFirstRecordByFilter(
		collection.Id,
		"email = {:email}",
		dbx.Params{
			"email": email,
		},
	)

	if err != nil {
		error_msg := fmt.Sprintf("failed to find user (SHD_RCP_173), err:%v", err)
		sysdatastores.AddActivityLog(ApiTypes.ActivityLogDef{
			ActivityName: ApiTypes.ActivityName_Auth,
			ActivityType: ApiTypes.ActivityType_PasswordUpdateFailure,
			AppName:      ApiTypes.AppName_Auth,
			ModuleName:   ApiTypes.ModuleName_EmailAuth,
			ActivityMsg:  &error_msg,
			CallerLoc:    "SHD_RCE_216"})

		return false, http.StatusInternalServerError, error_msg
	}

	record.SetPassword(password)

	// Save the record
	log.Printf("[req=%s] ========== (SHD_RCP_188), update password:%s", reqID, email)
	if err := p.e.App.Save(record); err != nil {
		error_msg := fmt.Sprintf("failed saving user (ARX_RCP_218), user_email:%s, err:%v", email, err)
		log.Printf("[req=%s] ***** Alarm:%s", reqID, error_msg)
		return false, http.StatusInternalServerError, error_msg
	}

	return true, 0, ""
}

// CreateUser adds a user if the user does not exist.
// Otherwise, it updates the record.
// Users are identified by user_email.
func (p *pbContext) UpsertUser(
	ctx context.Context,
	reqID string,
	user_id_type string,
	user_name string,
	plain_password string,
	user_email string,
	auth_type string,
	status string,
	first_name string,
	last_name string,
	token string,
	avatar string) (ApiTypes.UserInfo, error) {

	call_flow := ctx.Value(ApiTypes.CallFlowKey)
	log.Printf("[req=%s] UpsertUser (SHD_RCP_130), email:%s, password:%s, token:%s", reqID, user_email, plain_password, token)
	var user_info ApiTypes.UserInfo

	// Get the collection
	collection, err := p.e.App.FindCollectionByNameOrId("users")
	if err != nil {
		return user_info, err
	}

	record, err := p.e.App.FindFirstRecordByFilter(
		collection.Id,
		"email = {:email}",
		dbx.Params{
			"email": user_email,
		},
	)

	if err != nil && !errors.Is(err, sql.ErrNoRows) {
		error_msg := fmt.Sprintf("failed to check existing user: %v (%s->SHD_RCP_262)", err, call_flow)
		log.Printf("***** Alarm:%s", error_msg)
		return user_info, fmt.Errorf("%s", error_msg)
	}

	is_dirty := false
	if errors.Is(err, sql.ErrNoRows) {
		// Record not found. Create it
		record = core.NewRecord(collection)
		record.Set("email", user_email)
		record.SetPassword(plain_password)
		record.Set("firstName", first_name)
		record.Set("lastName", last_name)
		record.Set("tokenKey1", token)
		log.Printf("[req=%s] ============ UpsertUser (SHD_RCP_141), email:%s, name:%s, token:%s", reqID, user_email, user_name, token)

		if strings.TrimSpace(avatar) != "" {
			file, err := p.UploadImageFromURL(reqID, avatar, "users")
			if err != nil {
				error_msg := fmt.Sprintf("failed uploading file, avatar:%s, err:%v (%s->SHD_RCP_281)", avatar, err, call_flow)
				log.Printf("[req=%s] ***** Alarm:%s", reqID, error_msg)
			} else {
				if record.GetString("avatar") == "" {
					// Note that it does not update unless it is empty
					record.Set("avatar", file)
				}
			}
		}

		user_info.Email = user_email
		user_info.FirstName = first_name
		user_info.LastName = last_name
		user_info.UserIdType = user_id_type
		user_info.UserName = user_name
		user_info.Password = plain_password
		user_info.AuthType = auth_type
		user_info.UserStatus = status
		user_info.VToken = token
		user_info.Avatar = avatar
		is_dirty = true
	} else {
		user_info.Email = user_email
		user_info.UserIdType = user_id_type
		user_info.AuthType = auth_type
		user_info.UserStatus = status
		user_info.Admin = record.GetBool("admin")
		user_info.EmailVisibility = record.GetBool("emailVisibility")
		user_info.Verified = record.GetBool("verified")

		if record.GetString("firstName") == "" {
			record.Set("firstName", first_name)
			user_info.FirstName = first_name
			is_dirty = true
		} else {
			user_info.FirstName = record.GetString("firstName")
		}

		if record.GetString("lastName") == "" {
			record.Set("lastName", last_name)
			user_info.LastName = last_name
			is_dirty = true
		} else {
			user_info.LastName = record.GetString("lastName")
		}

		if plain_password != "" {
			record.SetPassword(plain_password)
			user_info.Password = plain_password
			is_dirty = true
		} else {
			user_info.Password = record.GetString("password")
		}

		if token != "" {
			record.Set("tokenKey1", token)
			user_info.VToken = token
			is_dirty = true
		} else {
			user_info.VToken = record.GetString("tokenKey1")
		}

		if strings.TrimSpace(avatar) != "" {
			file, err := p.UploadImageFromURL(reqID, avatar, "users")
			if err != nil {
				error_msg := fmt.Sprintf("failed uploading file, avatar:%s, err:%v (%s->SHD_RCP_346)", avatar, err, call_flow)
				log.Printf("[req=%s] ***** Alarm:%s", reqID, error_msg)
			} else {
				if record.GetString("avatar") == "" {
					// Note that it does not update unless it is empty
					record.Set("avatar", file)
				}
			}
			user_info.Avatar = avatar
		} else {
			user_info.Avatar = record.GetString("avatar")
		}
	}

	if is_dirty {
		// Save the record
		log.Printf("[req=%s] (SHD_RCP_196), save users record:%s", reqID, user_email)
		if err := p.e.App.Save(record); err != nil {
			error_msg := fmt.Sprintf("failed saving user, user_email:%s, err:%v (%s->SHD_RCP_364)", user_email, err, call_flow)
			log.Printf("[req=%s] ***** Alarm:%s", reqID, error_msg)
			return user_info, fmt.Errorf("%s", error_msg)
		}
	}

	return user_info, nil
}

func (p *pbContext) SaveSession(
	reqID string,
	login_method string,
	session_id string,
	user_name string,
	user_name_type string,
	user_reg_id string,
	user_email string,
	expiry time.Time) error {
	collection, err := p.e.App.FindCollectionByNameOrId("login_sessions")
	if err != nil {
		return err
	}

	// Create a new record in that collection
	record := core.NewRecord(collection)
	record.Set("login_method", login_method)
	record.Set("session_id", session_id)
	record.Set("status", "active")
	record.Set("user_name", user_name)
	record.Set("user_name_type", user_name_type)
	record.Set("user_reg_id", user_reg_id)
	record.Set("user_email", user_email)
	record.Set("expires_at", expiry)

	// Save the record
	if err := p.e.App.Save(record); err != nil {
		error_msg := fmt.Sprintf("failed saving login session (ARX_RCP_123), session_id:%s, user_email:%s",
			session_id, user_email)
		log.Printf("[req=%s] ***** Alarm:%s", reqID, error_msg)
		return fmt.Errorf("%s", error_msg)
	}

	return nil
}

func (p *pbContext) Bind(reqID string, v interface{}) error {
	// Only support JSON for now (most common in APIs)
	// In the future, we should support:
	//	- application/json → uses JSON decoder (supported)
	//  - application/x-www-form-urlencoded → parses form (TBD)
	//  - multipart/form-data → parses multipart (TBD)
	//  - Query params → binds from URL query (TBD)
	content_type := p.e.Request.Header.Get("Content-Type")
	if content_type != "application/json" {
		error_msg := fmt.Sprintf("unsupported content type: only application/json allowed (SHD_RCP_068), content_type:%s", content_type)
		log.Printf("[req:%s] ***** Alarm:%s", reqID, error_msg)
		return fmt.Errorf("%s", error_msg)
	}

	// For some unknown reason, we need to read the body first and then decode it.
	io.ReadAll(p.e.Request.Body)

	// Use strict decoding (reject trailing garbage)
	dec := json.NewDecoder(p.e.Request.Body)
	dec.DisallowUnknownFields() // optional: reject unknown fields

	if err := dec.Decode(v); err != nil {
		if err == io.EOF {
			error_msg := "empty request body (SHD_RCP_077)"
			log.Printf("[req=%s] ***** Alarm:%s", reqID, error_msg)
			return fmt.Errorf("%s", error_msg)
		}
		error_msg := fmt.Sprintf("invalid JSON (SHD_RCP_083): %v", err)
		log.Printf("[req=%s] ***** Alarm:%s", reqID, error_msg)
		return fmt.Errorf("%s", error_msg)
	}

	// Enforce single JSON object (reject trailing data)
	if dec.More() {
		error_msg := "extra data after JSON object (SHD_RCP_090)"
		log.Printf("[req=%s] ***** Alarm:%s", reqID, error_msg)
		return fmt.Errorf("%s", error_msg)
	}

	return nil
}

func (p *pbContext) ReqID() string {
	ctx := p.e.Request.Context()
	if id, ok := ctx.Value(PocketReqIDKey).(string); ok && id != "" {
		return id
	}
	// Generate and store
	id := ApiUtils.GenerateRequestID("p")
	newCtx := context.WithValue(ctx, PocketReqIDKey, id)
	*p.e.Request = *p.e.Request.WithContext(newCtx)
	return id
}

func (p *pbContext) SetReqID(reqID string) {
	ctx := context.WithValue(p.e.Request.Context(), PocketReqIDKey, reqID)
	*p.e.Request = *p.e.Request.WithContext(ctx)
}

// Private context key (avoids collisions)
var PocketReqIDKey ReqIDKeyT = "pocket/reqID"

func (p *pbContext) IsAuthenticated(
	reqID string,
	loc string) (ApiTypes.UserInfo, error) {
	cookie := p.GetCookie("session_id")
	if cookie != "" {
		user_info, valid, _ := p.IsValidSessionPocket(reqID, cookie)
		if valid {
			log.Printf("[req=%s] Cookie valid (SHD_RCP_077), email:%s", reqID, user_info.Email)
			return user_info, nil
		}

		// Cookie exists but is invalid → delete it
		log.Printf("[req=%s] Cookie invalid, remove cookie:%s (SHD_MAT_044)", reqID, cookie)
		p.SetCookie(cookie)
		return user_info, fmt.Errorf("cookie invalid, cookie removed (SHD_RCP_092)")
	}

	log.Printf("[req=%s] no cookie found, loc:%s (SHD_RCP_095)", reqID, loc)
	var user_info ApiTypes.UserInfo
	return user_info, fmt.Errorf("user not logged in (SHD_RCP_095)")
}

func (p *pbContext) GetUserInfoByEmail(reqID string, email string) (ApiTypes.UserInfo, bool) {
	var user_info ApiTypes.UserInfo
	users_table_name := ApiTypes.LibConfig.SystemTableNames.TableNameUsers
	records, err := p.e.App.FindRecordsByFilter(
		users_table_name,
		`email = {:email}`,
		"created",
		10, // limit
		0,  // offset
		map[string]interface{}{
			"email": email,
		})

	if err != nil || len(records) > 1 {
		var error_msg = fmt.Sprintf("failed retrieving users (SHD_RCP_512), error:%v", err)
		log.Printf("[req=%s] ***** Alarm:%s", reqID, error_msg)
		return user_info, false
	}

	if len(records) <= 0 {
		// The cookie is not valid.
		var error_msg = fmt.Sprintf("user not found (SHD_RCP_337), error:%v", err)
		log.Printf("[req=%s] +++++ WARN %s", reqID, error_msg)
		return user_info, false
	}

	user_info.UserId = records[0].GetString("id")
	user_info.Email = records[0].GetString("email")
	user_info.Admin = records[0].GetBool("admin")
	user_info.EmailVisibility = records[0].GetBool("emailVisibility")
	user_info.FirstName = records[0].GetString("firstName")
	user_info.LastName = records[0].GetString("lastName")
	user_info.VToken = records[0].GetString("tokenKey1")
	user_info.Verified = records[0].GetBool("verified")
	user_info.Avatar = records[0].GetString("avatar")
	user_info.OutlookRefreshToken = records[0].GetString("outlookRefreshToken")
	user_info.OutlookAccessToken = records[0].GetString("outlookAccessToken")
	user_info.OutlookTokenExpiresAt = records[0].GetString("outlookTokenExpiresAt")
	log.Printf("[req=%s] Retrieved user info (SHD_RCP_355), email:%s", reqID, user_info.Email)
	return user_info, true
}

func (p *pbContext) GetUserInfoByUserID(reqID string, user_id string) (ApiTypes.UserInfo, bool) {
	var user_info ApiTypes.UserInfo
	users_table_name := ApiTypes.LibConfig.SystemTableNames.TableNameUsers
	records, err := p.e.App.FindRecordsByFilter(
		users_table_name,
		`id = {:id}`,
		"created",
		10, // limit
		0,  // offset
		map[string]interface{}{
			"id": user_id,
		})

	if err != nil || len(records) > 1 {
		var error_msg = fmt.Sprintf("failed retrieving users (SHD_RCP_554), table:%s, num_records:%d, error:%v", users_table_name, len(records), err)
		log.Printf("[req=%s] ***** Alarm:%s", reqID, error_msg)
		return user_info, false
	}

	if len(records) <= 0 {
		// The cookie is not valid.
		var error_msg = fmt.Sprintf("user not found (SHD_RCP_337), error:%v", err)
		log.Printf("[req=%s] +++++ WARN %s", reqID, error_msg)
		return user_info, false
	}

	user_info.UserId = records[0].GetString("id")
	user_info.Email = records[0].GetString("email")
	user_info.Admin = records[0].GetBool("admin")
	user_info.EmailVisibility = records[0].GetBool("emailVisibility")
	user_info.FirstName = records[0].GetString("firstName")
	user_info.LastName = records[0].GetString("lastName")
	user_info.VToken = records[0].GetString("tokenKey1")
	user_info.Verified = records[0].GetBool("verified")
	user_info.Avatar = records[0].GetString("avatar")
	user_info.OutlookRefreshToken = records[0].GetString("outlookRefreshToken")
	user_info.OutlookAccessToken = records[0].GetString("outlookAccessToken")
	user_info.OutlookTokenExpiresAt = records[0].GetString("outlookTokenExpiresAt")
	log.Printf("[req=%s] Retrieved user info (SHD_RCP_355), email:%s", reqID, user_info.Email)
	return user_info, true
}

func (p *pbContext) VerifyUserPassword(
	reqID string,
	email string,
	plaintextPassword string) (bool, int, string) {
	// Find the auth record by email (this works for the "users" collection if it's set as auth collection)
	user, err := p.e.App.FindAuthRecordByEmail("users", email)
	if err != nil {
		error_msg := fmt.Sprintf("user not found (SHD_RCP_503), email:%s", email)
		log.Printf("[req=%s] +++++ Warning:%s (SHD_EML_240)", reqID, error_msg)

		sysdatastores.AddActivityLog(ApiTypes.ActivityLogDef{
			ActivityName: ApiTypes.ActivityName_Auth,
			ActivityType: ApiTypes.ActivityType_UserNotAuthed,
			AppName:      ApiTypes.AppName_Auth,
			ModuleName:   ApiTypes.ModuleName_EmailAuth,
			ActivityMsg:  &error_msg,
			CallerLoc:    "SHD_EML_248"})

		return false, http.StatusUnauthorized, error_msg
	}

	// Let Pocketbase verify the password
	if !user.ValidatePassword(plaintextPassword) {
		error_msg := fmt.Sprintf("password not match (SHD_RCP_519), email:%s, password:%s", email, plaintextPassword)
		log.Printf("[req=%s] +++++ Warning:%s (SHD_EML_240)", reqID, error_msg)

		sysdatastores.AddActivityLog(ApiTypes.ActivityLogDef{
			ActivityName: ApiTypes.ActivityName_Auth,
			ActivityType: ApiTypes.ActivityType_InvalidPassword,
			AppName:      ApiTypes.AppName_Auth,
			ModuleName:   ApiTypes.ModuleName_EmailAuth,
			ActivityMsg:  &error_msg,
			CallerLoc:    "SHD_EML_248"})

		return false, http.StatusUnauthorized, error_msg
	}

	return true, 0, ""
}

func (p *pbContext) GetUserInfoByToken(reqID string, token string) (ApiTypes.UserInfo, bool) {
	var user_info ApiTypes.UserInfo
	users_table_name := ApiTypes.LibConfig.SystemTableNames.TableNameUsers
	records, err := p.e.App.FindRecordsByFilter(
		users_table_name,
		`tokenKey1 = {:tokenKey1}`,
		"created",
		10, // limit
		0,  // offset
		map[string]interface{}{
			"tokenKey1": token,
		})

	if err != nil || len(records) > 1 {
		var error_msg = fmt.Sprintf("failed retrieving users (SHD_RCP_636), error:%v", err)
		log.Printf("[req=%s] ***** Alarm:%s", reqID, error_msg)
		return user_info, false
	}

	if len(records) <= 0 {
		// The cookie is not valid.
		var error_msg = fmt.Sprintf("user not found (SHD_RCP_337), error:%v", err)
		log.Printf("[req=%s] +++++ WARN %s", reqID, error_msg)
		return user_info, false
	}

	user_info.UserId = records[0].GetString("id")
	user_info.Email = records[0].GetString("email")
	user_info.Admin = records[0].GetBool("admin")
	user_info.EmailVisibility = records[0].GetBool("emailVisibility")
	user_info.FirstName = records[0].GetString("firstName")
	user_info.LastName = records[0].GetString("lastName")
	user_info.VToken = records[0].GetString("tokenKey1")
	user_info.Verified = records[0].GetBool("verified")
	user_info.Avatar = records[0].GetString("avatar")
	user_info.OutlookRefreshToken = records[0].GetString("outlookRefreshToken")
	user_info.OutlookAccessToken = records[0].GetString("outlookAccessToken")
	user_info.OutlookTokenExpiresAt = records[0].GetString("outlookTokenExpiresAt")
	return user_info, true
}

func (p *pbContext) IsValidSessionPocket(reqID string, session_id string) (ApiTypes.UserInfo, bool, error) {
	// This function checks whether 'session_id' is valid in the sessions table.
	// If valid, return the record.
	login_sessions_table_name := ApiTypes.LibConfig.SystemTableNames.TableNameLoginSessions
	session_records, err := p.e.App.FindRecordsByFilter(
		login_sessions_table_name,
		`session_id = {:session_id}`,
		"created",
		10, // limit
		0,  // offset
		map[string]interface{}{
			"session_id": session_id,
		})

	if err != nil || len(session_records) > 1 {
		var error_msg = fmt.Sprintf("failed retrieving session (SHD_RCP_170), error:%v", err)
		log.Printf("%s", error_msg)
		var user_info ApiTypes.UserInfo
		return user_info, false, fmt.Errorf("%s", error_msg)
	}

	if len(session_records) <= 0 {
		// The cookie is not valid.
		var error_msg = fmt.Sprintf("session not found (SHD_RCP_191), error:%v, session_id:%s", err, session_id)
		log.Printf("[req=%s], %s", reqID, error_msg)
		var user_info ApiTypes.UserInfo
		return user_info, false, fmt.Errorf("%s", error_msg)
	}

	user_email := session_records[0].GetString("user_email")
	session_record := make(map[string]interface{})
	session_record["login_method"] = session_records[0].GetString("login_method")
	session_record["status"] = session_records[0].GetString("status")
	session_record["user_name"] = session_records[0].GetString("user_name")
	session_record["email"] = user_email
	session_record["expires_at"] = session_records[0].GetString("expires_at")
	log.Printf("[req=%s] Found session (SHD_RCP_188), session_id:%s, email:%s",
		reqID, session_id, session_record["email"])

	user_info, exist := p.GetUserInfoByEmail(reqID, user_email)
	if !exist {
		var error_msg = fmt.Sprintf("cookie not valid, user not found (SHD_RCP_191), email:%s", user_email)
		log.Printf("[req=%s] +++++ WARN:%s", reqID, error_msg)
		var user_info ApiTypes.UserInfo
		return user_info, false, fmt.Errorf("%s", error_msg)
	}

	if !user_info.Verified {
		var error_msg = fmt.Sprintf("cookie not valid, user account not verified yet(SHD_RCP_399), email:%s", user_email)
		log.Printf("[req=%s] +++++ WARN:%s", reqID, error_msg)
		var user_info ApiTypes.UserInfo
		return user_info, false, fmt.Errorf("%s", error_msg)
	}

	return user_info, true, nil
}

// Helper: download image from URL and upload to PB storage
func (p *pbContext) UploadImageFromURL(
	reqID string,
	imageURL string,
	collectionName string) (*filesystem.File, error) {

	// 1. Fetch the image
	resp, err := http.Get(imageURL)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch image: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("non-200 status fetching image: %d", resp.StatusCode)
	}

	// 2. Determine file extension from URL or Content-Type
	ext := ".jpg" // default
	contentType := resp.Header.Get("Content-Type")
	if strings.HasPrefix(contentType, "image/png") {
		ext = ".png"
	} else if strings.HasPrefix(contentType, "image/jpeg") {
		ext = ".jpg"
	} else if strings.HasPrefix(contentType, "image/gif") {
		ext = ".gif"
	} else {
		// Fallback: try from URL
		urlExt := path.Ext(imageURL)
		if urlExt != "" && (strings.HasSuffix(urlExt, ".jpg") || strings.HasSuffix(urlExt, ".jpeg") ||
			strings.HasSuffix(urlExt, ".png") || strings.HasSuffix(urlExt, ".gif")) {
			ext = urlExt
		}
	}

	// 3. Create a temporary reader
	data, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read image: %w", err)
	}

	// 4. Upload to PocketBase storage
	filename := fmt.Sprintf("avatar_%d%s", time.Now().UnixNano(), ext)
	file, err := filesystem.NewFileFromBytes(data, filename)
	if err != nil {
		return nil, fmt.Errorf("failed to upload file to PB: %w", err)
	}

	log.Printf("[req=%s] Uploaded avatar image as: %s", reqID, filename)
	return file, nil
}

func (p *pbContext) SendHTMLResp(errorHTML string) error {
	p.e.Response.Header().Set("Content-Type", "text/html; charset=utf-8")
	p.e.Response.WriteHeader(http.StatusBadRequest)
	_, err := p.e.Response.Write([]byte(errorHTML))
	return err
}

func (p *pbContext) Redirect(redirect_url string, status_code int) error {
	http.Redirect(p.e.Response, p.e.Request, redirect_url, status_code)
	return nil
}

func (p *pbContext) SendJSONResp(status_code int, json_resp map[string]interface{}) error {
	return p.e.JSON(status_code, json_resp)
}
