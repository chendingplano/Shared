////////////////////////////////////////////////////////////
//
// Description:
// A class to interface with Kratos for authentication
//
// Created: 2026/02/07 by Chen Ding, Generated by Claude Code
////////////////////////////////////////////////////////////

package auth

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"os"
	"strings"
	"time"

	"github.com/chendingplano/shared/go/api/ApiTypes"
	"github.com/chendingplano/shared/go/api/ApiUtils"
	"github.com/chendingplano/shared/go/api/EchoFactory"
	"github.com/chendingplano/shared/go/api/loggerutil"
	"github.com/chendingplano/shared/go/api/sysdatastores"
	"github.com/labstack/echo/v4"
	ory "github.com/ory/client-go"
)

// KratosClient wraps the Ory SDK client for Kratos operations
type KratosClient struct {
	client    *ory.APIClient
	publicURL string
	logger    ApiTypes.JimoLogger
}

// Global Kratos client instance
var kratosClient *KratosClient

// InitKratosClient initializes the global Kratos client.
// Call this during application startup.
func InitKratosClient() {
	kratosPublicURL := os.Getenv("KRATOS_PUBLIC_URL")
	err_msg := ""
	if kratosPublicURL == "" {
		err_msg = "missing KRATOS_PUBLIC_URL env variable. Default to http://localhost:4433"
		kratosPublicURL = "http://localhost:4433"
	}

	config := ory.NewConfiguration()
	logger := loggerutil.CreateDefaultLogger("SHD_0207142900")
	if err_msg != "" {
		logger.Error(err_msg)
	}

	config.Servers = ory.ServerConfigurations{{URL: kratosPublicURL}}
	kratosClient = &KratosClient{
		client:    ory.NewAPIClient(config),
		publicURL: kratosPublicURL,
		logger:    logger,
	}

	EchoFactory.GetUserInfoByUserIDFunc = KratosGetIdentityByID
	EchoFactory.GetUserInfoByEmailFunc = KratosGetIdentityByEmail
	EchoFactory.KratosMarkUserVerifiedFunc = KratosMarkUserVerified
	EchoFactory.KratosUpdateIdentityFunc = KratosUpdateIdentityWrapper
	EchoFactory.UpdateAppTokenByEmailFunc = UpdateAppTokenByEmail
	EchoFactory.GetUserInfoByAppTokenFunc = KratosGetUserInfoByAppToken
}

// GetKratosClient returns the global Kratos client.
// Returns nil if not initialized.
func GetKratosClient() *KratosClient {
	return kratosClient
}

// KratosLoginRequest represents the login request body
type KratosLoginRequest struct {
	Email    string `json:"email"`
	Password string `json:"password"`
}

// KratosLoginResponse represents the successful login response
type KratosLoginResponse struct {
	Session     *ory.Session `json:"session"`
	RedirectURL string       `json:"redirect_url"`
}

// KratosErrorResponse represents an error response
type KratosErrorResponse struct {
	Status  string `json:"status"`
	Message string `json:"message"`
	LOC     string `json:"loc"`
}

// ValidateSession checks if the request has a valid Kratos session
func (k *KratosClient) ValidateSession(c echo.Context) (*ory.Session, error) {
	cookies := c.Request().Header.Get("Cookie")
	sessionToken := c.Request().Header.Get("X-Session-Token")

	// If no X-Session-Token header, check for our custom session_token cookie
	// (used when session token was stored from native API flow)
	if sessionToken == "" {
		if cookie, err := c.Cookie("session_token"); err == nil && cookie.Value != "" {
			sessionToken = cookie.Value
			k.logger.Info("Using session token from cookie", "token", sessionToken[:min(10, len(sessionToken))]+"...")
		}
	}

	ctx := context.Background()
	req := k.client.FrontendAPI.ToSession(ctx)

	// Pass cookies for browser flow sessions
	if cookies != "" {
		req = req.Cookie(cookies)
	}
	// Pass session token for native/API flow sessions
	if sessionToken != "" {
		req = req.XSessionToken(sessionToken)
	}

	session, resp, err := req.Execute()
	if err != nil {
		if strings.HasPrefix(err.Error(), "401") {
			k.logger.Warn("user not logged in", "error", err)
		} else {
			k.logger.Error("failed validating session", "error", err)
		}

		if resp != nil {
			k.logger.Info("resp", "resp", resp)
		}
		if resp != nil && resp.StatusCode == http.StatusUnauthorized {
			return nil, echo.NewHTTPError(http.StatusUnauthorized,
				fmt.Sprintf("No valid session found, error:%v (SHD_0207142600)", err))
		}
		// Handle 403 Forbidden - this typically means AAL2 is required but session is AAL1
		// The user has 2FA configured but hasn't completed it
		if resp != nil && resp.StatusCode == http.StatusForbidden {
			return nil, echo.NewHTTPError(http.StatusForbidden,
				fmt.Sprintf("Session requires two-factor authentication, error:%v (SHD_0207142602)", err))
		}
		return nil, echo.NewHTTPError(http.StatusInternalServerError,
			fmt.Sprintf("Failed to validate session, error:%v (SHD_0207142601)", err))
	}

	return session, nil
}

// HandleEmailLoginKratos handles email/password login via Ory Kratos.
// This is the Kratos-based replacement for HandleEmailLogin.
//
// Flow:
//  1. Create a native login flow via Kratos API
//  2. Submit email/password credentials to the flow
//  3. On success, return session info and redirect URL
//  4. Kratos sets the session cookie automatically
func HandleEmailLoginKratos(c echo.Context) error {
	rc := EchoFactory.NewFromEcho(c, "SHD_0211103000")
	defer rc.Close()
	logger := rc.GetLogger()

	// SECURITY: Rate limiting to prevent brute-force attacks
	clientIP := c.RealIP()
	allowed, remaining, retryAfter := CheckLoginRateLimit(clientIP)
	if !allowed {
		logger.Warn("Rate limit exceeded for login",
			"ip", clientIP,
			"retry_after", retryAfter.String())
		return c.JSON(http.StatusTooManyRequests, KratosErrorResponse{
			Status:  "error",
			Message: "Too many login attempts. Please try again later.",
			LOC:     "SHD_0207143400",
		})
	}
	_ = remaining

	// SECURITY: Validate request origin to prevent CSRF attacks
	if !IsSafeOrigin(c) {
		logger.Warn("CSRF protection: rejected cross-origin request",
			"origin", c.Request().Header.Get("Origin"),
			"referer", c.Request().Header.Get("Referer"))
		return c.JSON(http.StatusForbidden, KratosErrorResponse{
			Status:  "error",
			Message: "Invalid request origin",
			LOC:     "SHD_0207143401",
		})
	}

	body, err := io.ReadAll(c.Request().Body)
	if err != nil {
		logger.Error("Failed to read request body", "error", err)
		return c.JSON(http.StatusBadRequest, KratosErrorResponse{
			Status:  "error",
			Message: "Failed to read request body",
			LOC:     "SHD_0207144100",
		})
	}

	statusCode, response := HandleEmailLoginKratosBase(rc, body, clientIP, c)
	return c.JSON(statusCode, response)
}

// HandleEmailLoginKratosBase processes email login requests via Kratos.
// Returns (status_code, response_map).
func HandleEmailLoginKratosBase(
	rc ApiTypes.RequestContext,
	body []byte,
	clientIP string,
	c echo.Context) (int, map[string]interface{}) {

	logger := rc.GetLogger()
	logger.Info("HandleEmailLoginKratos called")

	if kratosClient == nil {
		InitKratosClient()
	}

	// Parse request
	var req KratosLoginRequest
	if err := json.Unmarshal(body, &req); err != nil {
		errorMsg := "invalid request body (SHD_0211103001)"
		logger.Error("invalid request body", "error", err)

		sysdatastores.AddActivityLog(ApiTypes.ActivityLogDef{
			ActivityName: ApiTypes.ActivityName_Auth,
			ActivityType: ApiTypes.ActivityType_BadRequest,
			AppName:      ApiTypes.AppName_Auth,
			ModuleName:   ApiTypes.ModuleName_EmailAuth,
			ActivityMsg:  &errorMsg,
			CallerLoc:    "SHD_0211103002",
		})

		return http.StatusBadRequest, map[string]interface{}{
			"status":  "error",
			"message": errorMsg,
			"LOC":     "SHD_0207144100",
		}
	}

	if !isValidEmail(req.Email) {
		errorMsg := "invalid email format (SHD_0211103003)"
		logger.Error("invalid email format", "email", req.Email)

		sysdatastores.AddActivityLog(ApiTypes.ActivityLogDef{
			ActivityName: ApiTypes.ActivityName_Auth,
			ActivityType: ApiTypes.ActivityType_BadEmail,
			AppName:      ApiTypes.AppName_Auth,
			ModuleName:   ApiTypes.ModuleName_EmailAuth,
			ActivityMsg:  &errorMsg,
			CallerLoc:    "SHD_0211103004",
		})

		return http.StatusBadRequest, map[string]interface{}{
			"status":  "error",
			"message": errorMsg,
			"LOC":     "SHD_0211103005",
		}
	}

	// SECURITY: Check per-account rate limiting
	accountAllowed, _, accountRetryAfter := CheckAccountLockout(req.Email)
	if !accountAllowed {
		logger.Warn("Account locked due to too many failed attempts",
			"email", req.Email,
			"retry_after", accountRetryAfter.String())

		sysdatastores.AddActivityLog(ApiTypes.ActivityLogDef{
			ActivityName: ApiTypes.ActivityName_Auth,
			ActivityType: ApiTypes.ActivityType_AuthFailure,
			AppName:      ApiTypes.AppName_Auth,
			ModuleName:   ApiTypes.ModuleName_EmailAuth,
			ActivityMsg:  func() *string { s := fmt.Sprintf("Account locked: %s", req.Email); return &s }(),
			CallerLoc:    "SHD_0207144101",
		})

		return http.StatusTooManyRequests, map[string]interface{}{
			"status":  "error",
			"message": "This account is temporarily locked due to too many failed login attempts.",
			"LOC":     "SHD_0207144102",
		}
	}

	ctx := context.Background()

	// Step 1: Create a native login flow
	// Native flows are for API clients (not browser redirects)
	loginFlow, resp, err := kratosClient.client.FrontendAPI.CreateNativeLoginFlow(ctx).Execute()
	if err != nil {
		logger.Error("Failed to create login flow", "error", err)
		if resp != nil {
			logger.Error("Kratos response", "status", resp.StatusCode)
		}

		return http.StatusInternalServerError, map[string]interface{}{
			"status":  "error",
			"message": "Failed to initialize login",
			"LOC":     "SHD_0211103006",
		}
	}

	flowID := loginFlow.Id
	logger.Info("Created login flow", "flow_id", flowID)

	// Step 2: Submit the login credentials to Kratos
	updateLoginFlowBody := ory.UpdateLoginFlowBody{
		UpdateLoginFlowWithPasswordMethod: &ory.UpdateLoginFlowWithPasswordMethod{
			Method:     "password",
			Identifier: req.Email,
			Password:   req.Password,
		},
	}

	successfulLogin, resp, err := kratosClient.client.FrontendAPI.UpdateLoginFlow(ctx).
		Flow(flowID).
		UpdateLoginFlowBody(updateLoginFlowBody).
		Execute()

	if err != nil {
		// Parse Kratos error response for better error messages
		errorMessage := "Invalid email or password"
		if resp != nil {
			if resp.StatusCode == http.StatusBadRequest || resp.StatusCode == http.StatusUnauthorized {
				logger.Warn("Login failed", "email", req.Email, "error", err, "statusCode", resp.StatusCode)
				// Read the error body for more details
				if respBody, readErr := io.ReadAll(resp.Body); readErr == nil {
					var kratosError map[string]interface{}
					if jsonErr := json.Unmarshal(respBody, &kratosError); jsonErr == nil {
						if ui, ok := kratosError["ui"].(map[string]interface{}); ok {
							if messages, ok := ui["messages"].([]interface{}); ok && len(messages) > 0 {
								if msg, ok := messages[0].(map[string]interface{}); ok {
									if text, ok := msg["text"].(string); ok {
										errorMessage = text
									}
								}
							}
						}
					}
				}
			} else {
				logger.Warn("Login failed (unrecog status code)",
					"email", req.Email, "error", err, "statusCode", resp.StatusCode)
				errorMessage = fmt.Sprintf("login failed, unrecog statusCode:%d, email:%s", resp.StatusCode, req.Email)
			}
		} else {
			logger.Error("Login failed (resp is nil)", "email", req.Email, "error", err)
			errorMessage = fmt.Sprintf("login failed (resp is nil), email:%s", req.Email)
		}

		sysdatastores.AddActivityLog(ApiTypes.ActivityLogDef{
			ActivityName: ApiTypes.ActivityName_Auth,
			ActivityType: ApiTypes.ActivityType_AuthFailure,
			AppName:      ApiTypes.AppName_Auth,
			ModuleName:   ApiTypes.ModuleName_EmailAuth,
			ActivityMsg:  func() *string { s := fmt.Sprintf("Login failed: %s", req.Email); return &s }(),
			CallerLoc:    "SHD_0211103007",
		})

		return http.StatusUnauthorized, map[string]interface{}{
			"status":  "error",
			"message": errorMessage,
			"LOC":     "SHD_0207144103",
		}
	}

	// Success! We have a valid session
	session := successfulLogin.Session
	if session.Id == "" {
		logger.Error("Login succeeded but no session returned")
		return http.StatusInternalServerError, map[string]interface{}{
			"status":  "error",
			"message": "Login succeeded but session creation failed",
			"LOC":     "SHD_0207144104",
		}
	}

	// Check if the session is AAL1 and identity has 2FA configured
	// This means user needs to complete 2FA before accessing protected resources
	sessionAAL := session.GetAuthenticatorAssuranceLevel()
	logger.Info("Session AAL after password login",
		"aal", sessionAAL,
		"session_id", session.Id)

	// Extract user info from Kratos identity
	var email, firstName, lastName string
	// Check for admin/owner in metadata
	isAdmin := false
	isOwner := false
	identity := session.Identity

	// If identity is nil, try to fetch it via Admin API using the email
	// This can happen when Kratos doesn't include the full identity in the login response
	if identity == nil {
		logger.Info("Identity nil in login response, fetching via Admin API",
			"session_id", session.Id,
			"email", req.Email)

		adminURL := os.Getenv("KRATOS_ADMIN_URL")
		if adminURL == "" {
			adminURL = "http://localhost:4434"
		}

		// Use direct HTTP request to Admin API for better control
		httpClient := &http.Client{Timeout: 10 * time.Second}
		adminReq, _ := http.NewRequestWithContext(ctx, "GET",
			fmt.Sprintf("%s/admin/identities?credentials_identifier=%s", adminURL, url.QueryEscape(req.Email)), nil)
		adminReq.Header.Set("Accept", "application/json")

		adminResp, adminErr := httpClient.Do(adminReq)
		if adminErr != nil {
			logger.Error("Failed to call Admin API", "error", adminErr)
		} else {
			defer adminResp.Body.Close()
			respBody, _ := io.ReadAll(adminResp.Body)

			if adminResp.StatusCode == http.StatusOK {
				var identities []ory.Identity
				if jsonErr := json.Unmarshal(respBody, &identities); jsonErr == nil && len(identities) > 0 {
					identity = &identities[0]
					logger.Info("Successfully fetched identity via Admin API",
						"identity_id", identity.Id)
				} else {
					logger.Error("Failed to parse identities or no identities found",
						"parse_error", jsonErr,
						"response", string(respBody))
				}
			} else {
				logger.Error("Admin API returned error",
					"status_code", adminResp.StatusCode,
					"response", string(respBody))
			}
		}
	}

	// Now check if identity has TOTP credentials configured (indicating 2FA is required)
	// We need to fetch the identity with credentials to check this properly
	identityHasTOTP := false

	// First check if credentials are already present in the identity
	if identity != nil && identity.Credentials != nil {
		creds := *identity.Credentials
		if _, hasTOTP := creds["totp"]; hasTOTP {
			identityHasTOTP = true
			logger.Info("TOTP found in identity credentials")
		}
	}

	// If credentials not present, fetch identity with credentials from Admin API
	if identity != nil && !identityHasTOTP {
		adminURL := os.Getenv("KRATOS_ADMIN_URL")
		if adminURL == "" {
			adminURL = "http://localhost:4434"
		}

		httpClient := &http.Client{Timeout: 10 * time.Second}
		// Fetch specific identity with credentials included
		credReq, _ := http.NewRequestWithContext(ctx, "GET",
			fmt.Sprintf("%s/admin/identities/%s?include_credential=totp", adminURL, identity.Id), nil)
		credReq.Header.Set("Accept", "application/json")

		credResp, credErr := httpClient.Do(credReq)
		if credErr != nil {
			logger.Warn("Failed to fetch identity with credentials", "error", credErr)
		} else {
			defer credResp.Body.Close()
			credBody, _ := io.ReadAll(credResp.Body)

			logger.Info("Admin API credentials response",
				"status", credResp.StatusCode,
				"body_length", len(credBody))

			if credResp.StatusCode == http.StatusOK {
				// Parse as raw JSON to check for totp credentials
				// The ory.Identity struct may not properly unmarshal credentials
				var rawIdentity map[string]interface{}
				if jsonErr := json.Unmarshal(credBody, &rawIdentity); jsonErr == nil {
					if creds, ok := rawIdentity["credentials"].(map[string]interface{}); ok {
						logger.Info("Credentials found in response", "credential_types", getMapKeys(creds))
						if _, hasTOTP := creds["totp"]; hasTOTP {
							// TOTP credential exists - this means 2FA is configured
							// Note: TOTP credentials don't have "identifiers" like password credentials
							identityHasTOTP = true
							logger.Info("TOTP found via Admin API credentials check",
								"identity_id", identity.Id)
						}
					} else {
						logger.Info("No credentials field in response or wrong type")
					}
				} else {
					logger.Warn("Failed to parse identity with credentials",
						"parse_error", jsonErr)
				}
			}
		}
	}

	// If identity has TOTP and session is AAL1, user needs to complete 2FA
	if identityHasTOTP && sessionAAL == ory.AUTHENTICATORASSURANCELEVEL_AAL1 {
		logger.Info("User has 2FA configured, requiring TOTP verification",
			"email", req.Email,
			"session_id", session.Id)

		// Set the session token cookie so the 2FA verification can use it
		if successfulLogin.SessionToken != nil {
			sessionToken := *successfulLogin.SessionToken
			expiredTime := time.Now().Add(cookie_timeout_hours * time.Hour)

			cookie := &http.Cookie{
				Name:     "session_token",
				Value:    sessionToken,
				Path:     "/",
				Expires:  expiredTime,
				HttpOnly: true,
				Secure:   true,
				SameSite: http.SameSiteLaxMode,
			}
			c.SetCookie(cookie)
		}

		// Return response indicating 2FA is required
		return http.StatusOK, map[string]interface{}{
			"status":       "2fa_required",
			"message":      "Two-factor authentication required",
			"redirect_url": "/verify-2fa",
			"LOC":          "SHD_02111030008",
			"session_id":   session.Id,
		}
	}

	// SECURITY: Reset rate limits on successful login
	if clientIP != "" {
		ResetLoginRateLimits(clientIP, req.Email)
	}

	if identity == nil {
		logger.Error("Login succeeded but session has no identity",
			"session_id", session.Id,
			"email", req.Email)
		return http.StatusInternalServerError, map[string]interface{}{
			"status":  "error",
			"message": "Login succeeded but session has no identity",
			"LOC":     "SHD_02111030009",
		}
	}

	if identity.Traits != nil {
		traits, ok := identity.Traits.(map[string]interface{})
		if ok {
			email = traits["email"].(string)
			if name, ok := traits["name"].(map[string]interface{}); ok {
				if first, ok := name["first"].(string); ok {
					firstName = first
				}
				if last, ok := name["last"].(string); ok {
					lastName = last
				}
			}
		}
	}

	avatar := ""
	if identity.MetadataPublic != nil {
		if admin, ok := identity.MetadataPublic["admin"].(bool); ok {
			isAdmin = admin
		}
		if owner, ok := identity.MetadataPublic["is_owner"].(bool); ok {
			isOwner = owner
		}
		if av, ok := identity.MetadataPublic["avatar"].(string); ok {
			avatar = av
		}
	}

	// Set the session token as a cookie for the frontend
	// Kratos returns a session_token for native flows that we need to pass back
	// IMPORTANT: We use "session_token" cookie name (not "ory_kratos_session") because:
	// - "ory_kratos_session" is reserved for browser flow cookies set by Kratos itself
	// - Native/API flow tokens must be passed via X-Session-Token header to Kratos
	// - ValidateSession reads from "session_token" cookie and passes to Kratos via X-Session-Token
	if successfulLogin.SessionToken != nil {
		sessionToken := *successfulLogin.SessionToken
		expiredTime := time.Now().Add(cookie_timeout_hours * time.Hour)

		// Set the session token in our custom cookie
		cookie := &http.Cookie{
			Name:     "session_token",
			Value:    sessionToken,
			Path:     "/",
			Expires:  expiredTime,
			HttpOnly: true,
			Secure:   true,
			SameSite: http.SameSiteLaxMode,
		}
		c.SetCookie(cookie)

		// Also log the session
		customLayout := "2006-01-02 15:04:05"
		expiredTimeStr := expiredTime.Format(customLayout)

		sysdatastores.AddSessionLog(sysdatastores.SessionLogDef{
			LoginMethod:  "kratos_login",
			SessionID:    session.Id,
			AuthToken:    ApiUtils.MaskToken(sessionToken),
			Status:       "active",
			UserName:     email,
			UserNameType: "email",
			UserRegID:    identity.Id,
			UserEmail:    &email,
			CallerLoc:    "SHD_0211103010",
			ExpiresAt:    &expiredTimeStr,
		})
	}

	// Log successful login
	logger.Info("Kratos login success",
		"email", email,
		"identity_id", identity.Id,
		"session_id", session.Id,
		"admin", isAdmin,
		"is_owner", isOwner)

	msg := fmt.Sprintf("Kratos login success, email:%s, identity_id:%s",
		email, identity.Id)
	sysdatastores.AddActivityLog(ApiTypes.ActivityLogDef{
		ActivityName: ApiTypes.ActivityName_Auth,
		ActivityType: ApiTypes.ActivityType_UserLoginSuccess,
		AppName:      ApiTypes.AppName_Auth,
		ModuleName:   ApiTypes.ModuleName_EmailAuth,
		ActivityMsg:  &msg,
		CallerLoc:    "SHD_0211103011",
	})

	// Determine redirect URL (use existing GetRedirectURL from auth-util.go)
	// Note: isOwner handling would need to be added to GetRedirectURL if needed
	redirectURL := GetRedirectURL(rc, email, isAdmin, false)

	// Build response matching the expected frontend format
	return http.StatusOK, map[string]interface{}{
		"status":       "ok",
		"redirect_url": redirectURL,
		"LOC":          "SHD_0207144105",
		"session": map[string]interface{}{
			"id":               session.Id,
			"active":           session.Active,
			"expires_at":       session.ExpiresAt,
			"authenticated_at": session.AuthenticatedAt,
			"identity": map[string]interface{}{
				"id": identity.Id,
				"traits": map[string]interface{}{
					"email": email,
					"name": map[string]interface{}{
						"first": firstName,
						"last":  lastName,
					},
				},
				"metadata_public": map[string]interface{}{
					"admin":    isAdmin,
					"is_owner": isOwner,
					"avatar":   avatar,
				},
				"state":      identity.State,
				"created_at": identity.CreatedAt,
				"updated_at": identity.UpdatedAt,
			},
		},
	}
}

// HandleAuthMeKratos returns the current user's session info via Kratos.
// This is the Kratos-based replacement for HandleAuthMe.
func HandleAuthMeKratos(c echo.Context) error {
	rc := EchoFactory.NewFromEcho(c, "SHD_0211103012")
	defer rc.Close()
	logger := rc.GetLogger()

	if kratosClient == nil {
		InitKratosClient()
	}

	// Validate session with Kratos
	session, err := kratosClient.ValidateSession(c)
	if err != nil {
		logger.Warn("user not logged in", "error", err)
		return c.JSON(http.StatusUnauthorized, map[string]interface{}{
			"authenticated": false,
			"message":       "No valid session",
			"LOC":           "SHD_0207143100",
		})
	}

	identity := session.Identity
	traits := identity.Traits.(map[string]interface{})
	email, _ := ApiUtils.GetSafeString(traits, "email")

	var firstName, lastName string
	if name, ok := ApiUtils.GetSafeSubObj(traits, "name"); ok {
		if first, ok := name["first"].(string); ok {
			firstName = first
		}
		if last, ok := name["last"].(string); ok {
			lastName = last
		}
	}

	isAdmin := false
	isOwner := false
	avatarMe := ""
	if identity.MetadataPublic != nil {
		if admin, ok := identity.MetadataPublic["admin"].(bool); ok {
			isAdmin = admin
		}
		if owner, ok := identity.MetadataPublic["is_owner"].(bool); ok {
			isOwner = owner
		}
		if av, ok := identity.MetadataPublic["avatar"].(string); ok {
			avatarMe = av
		}
	}

	baseURL := os.Getenv("APP_BASE_URL")

	return c.JSON(http.StatusOK, map[string]interface{}{
		"base_url": baseURL,
		"LOC":      "SHD_0207143201",
		"session": map[string]interface{}{
			"id":               session.Id,
			"active":           session.Active,
			"expires_at":       session.ExpiresAt,
			"authenticated_at": session.AuthenticatedAt,
			"identity": map[string]interface{}{
				"id": identity.Id,
				"traits": map[string]interface{}{
					"email": email,
					"name": map[string]interface{}{
						"first": firstName,
						"last":  lastName,
					},
				},
				"metadata_public": map[string]interface{}{
					"admin":    isAdmin,
					"is_owner": isOwner,
					"avatar":   avatarMe,
				},
				"state":      identity.State,
				"created_at": identity.CreatedAt,
				"updated_at": identity.UpdatedAt,
			},
		},
	})
}

// HandleLogoutKratos handles logout via Kratos.
func HandleLogoutKratos(c echo.Context) error {
	rc := EchoFactory.NewFromEcho(c, "SHD_0211103013")
	defer rc.Close()
	logger := rc.GetLogger()

	if kratosClient == nil {
		InitKratosClient()
	}

	ctx := context.Background()
	cookies := c.Request().Header.Get("Cookie")

	// Create a browser logout flow (works for both browser and API clients)
	logoutFlow, resp, err := kratosClient.client.FrontendAPI.CreateBrowserLogoutFlow(ctx).
		Cookie(cookies).
		Execute()

	if err != nil {
		logger.Warn("Failed to create logout flow", "error", err)
		if resp != nil {
			logger.Warn("Kratos response", "status", resp.StatusCode)
		}
		// Even if Kratos fails, clear local cookies
		clearSessionCookies(c)
		return c.JSON(http.StatusOK, map[string]interface{}{
			"status":       "ok",
			"message":      "Logged out (local)",
			"redirect_url": "/login",
			"LOC":          "SHD_0207143300",
		})
	}

	// Submit the logout flow to actually log out using the logout token
	_, err = kratosClient.client.FrontendAPI.UpdateLogoutFlow(ctx).
		Token(logoutFlow.LogoutToken).
		Execute()

	if err != nil {
		logger.Warn("Failed to perform logout", "error", err)
	}

	// Clear local session cookies
	clearSessionCookies(c)

	logger.Info("Logout success")

	return c.JSON(http.StatusOK, map[string]interface{}{
		"status":       "ok",
		"message":      "Logged out successfully",
		"redirect_url": "/login",
		"LOC":          "SHD_0207143301",
	})
}

// clearSessionCookies clears all session-related cookies
func clearSessionCookies(c echo.Context) {
	cookiesToClear := []string{"session_id", "session_token", "ory_kratos_session"}
	for _, name := range cookiesToClear {
		cookie := &http.Cookie{
			Name:     name,
			Value:    "",
			Path:     "/",
			MaxAge:   -1,
			HttpOnly: true,
			Secure:   true,
		}
		c.SetCookie(cookie)
	}
}

// getMapKeys returns the keys of a map[string]interface{} for logging purposes
func getMapKeys(m map[string]interface{}) []string {
	keys := make([]string, 0, len(m))
	for k := range m {
		keys = append(keys, k)
	}
	return keys
}

// KratosAuthMiddleware requires a valid Kratos session.
// Use this middleware for protected routes.
func KratosAuthMiddleware(next echo.HandlerFunc) echo.HandlerFunc {
	return func(c echo.Context) error {
		if kratosClient == nil {
			InitKratosClient()
		}

		session, err := kratosClient.ValidateSession(c)
		if err != nil {
			return err
		}

		// Store session in context for handlers to access
		c.Set("kratos_session", session)
		c.Set("kratos_identity", session.Identity)

		// Also extract email for backwards compatibility with existing code
		traits := session.Identity.Traits.(map[string]interface{})
		if email, ok := traits["email"].(string); ok {
			ctx := context.WithValue(c.Request().Context(), ApiTypes.UserContextKey, email)
			c.SetRequest(c.Request().WithContext(ctx))
		}

		return next(c)
	}
}

// KratosSignupRequest represents the signup request body (Kratos format)
type KratosSignupRequest struct {
	Traits   KratosSignupTraits `json:"traits"`
	Password string             `json:"password"`
	// Legacy format fields (for backward compatibility)
	Email     string `json:"email,omitempty"`
	FirstName string `json:"first_name,omitempty"`
	LastName  string `json:"last_name,omitempty"`
}

// KratosSignupTraits represents the Kratos identity traits
type KratosSignupTraits struct {
	Email string            `json:"email"`
	Name  *KratosSignupName `json:"name,omitempty"`
}

// KratosSignupName represents the name trait
type KratosSignupName struct {
	First string `json:"first,omitempty"`
	Last  string `json:"last,omitempty"`
}

// KratosSignupResponse represents the signup response
type KratosSignupResponse struct {
	Status             string                 `json:"status"`
	Message            string                 `json:"message,omitempty"`
	RedirectURL        string                 `json:"redirect_url,omitempty"`
	Session            map[string]interface{} `json:"session,omitempty"`
	VerificationFlowID string                 `json:"verification_flow_id,omitempty"`
	LOC                string                 `json:"loc"`
}

// HandleEmailSignupKratos handles email/password registration via Ory Kratos.
// This is the Kratos-based replacement for HandleEmailSignup.
//
// Flow:
//  1. Create a native registration flow via Kratos API
//  2. Submit email, name traits, and password to the flow
//  3. On success, return session info (if auto-login enabled) or verification message
func HandleEmailSignupKratos(c echo.Context) error {
	rc := EchoFactory.NewFromEcho(c, "SHD_0211103014")
	defer rc.Close()
	logger := rc.GetLogger()

	// SECURITY: Validate request origin to prevent CSRF attacks
	if !IsSafeOrigin(c) {
		logger.Warn("CSRF protection: rejected cross-origin request",
			"origin", c.Request().Header.Get("Origin"),
			"referer", c.Request().Header.Get("Referer"))
		return c.JSON(http.StatusForbidden, KratosSignupResponse{
			Status:  "error",
			Message: "Invalid request origin",
			LOC:     "SHD_0211103015",
		})
	}

	body, err := io.ReadAll(c.Request().Body)
	if err != nil {
		logger.Error("Failed to read request body", "error", err)
		return c.JSON(http.StatusBadRequest, KratosSignupResponse{
			Status:  "error",
			Message: "Failed to read request body",
			LOC:     "SHD_0211103016",
		})
	}

	statusCode, response := HandleEmailSignupKratosBase(rc, body, c)
	return c.JSON(statusCode, response)
}

// HandleEmailSignupKratosBase processes email signup requests via Kratos.
// Returns (status_code, response).
func HandleEmailSignupKratosBase(
	rc ApiTypes.RequestContext,
	body []byte,
	c echo.Context) (int, KratosSignupResponse) {

	logger := rc.GetLogger()
	logger.Info("HandleEmailSignupKratos called")

	if kratosClient == nil {
		InitKratosClient()
	}

	// Parse request - support both Kratos format and legacy format
	var req KratosSignupRequest
	if err := json.Unmarshal(body, &req); err != nil {
		errorMsg := "invalid request body (SHD_0211103017)"
		logger.Error("invalid request body", "error", err)

		sysdatastores.AddActivityLog(ApiTypes.ActivityLogDef{
			ActivityName: ApiTypes.ActivityName_Auth,
			ActivityType: ApiTypes.ActivityType_BadRequest,
			AppName:      ApiTypes.AppName_Auth,
			ModuleName:   ApiTypes.ModuleName_EmailAuth,
			ActivityMsg:  &errorMsg,
			CallerLoc:    "SHD_0211103018",
		})

		return http.StatusBadRequest, KratosSignupResponse{
			Status:  "error",
			Message: errorMsg,
			LOC:     "SHD_0207180102",
		}
	}

	// Handle legacy format - if traits.email is empty but email field is set
	email := req.Traits.Email
	firstName := ""
	lastName := ""
	if req.Traits.Name != nil {
		firstName = req.Traits.Name.First
		lastName = req.Traits.Name.Last
	}

	// Fallback to legacy format fields
	if email == "" && req.Email != "" {
		email = req.Email
	}
	if firstName == "" && req.FirstName != "" {
		firstName = req.FirstName
	}
	if lastName == "" && req.LastName != "" {
		lastName = req.LastName
	}

	// Validate email
	if !isValidEmail(email) {
		errorMsg := "invalid email format"
		logger.Warn("invalid email format", "email", email)

		sysdatastores.AddActivityLog(ApiTypes.ActivityLogDef{
			ActivityName: ApiTypes.ActivityName_Auth,
			ActivityType: ApiTypes.ActivityType_InvalidEmail,
			AppName:      ApiTypes.AppName_Auth,
			ModuleName:   ApiTypes.ModuleName_EmailAuth,
			ActivityMsg:  &errorMsg,
			CallerLoc:    "SHD_0211103019",
		})

		return http.StatusBadRequest, KratosSignupResponse{
			Status:  "error",
			Message: errorMsg,
			LOC:     "SHD_0207180103",
		}
	}

	// Validate password
	if req.Password == "" {
		errorMsg := "password is required"
		logger.Warn("password is required")

		return http.StatusBadRequest, KratosSignupResponse{
			Status:  "error",
			Message: errorMsg,
			LOC:     "SHD_0207180104",
		}
	}

	// SECURITY: Validate password strength (using existing validation)
	passwordResult := ValidatePasswordDefault(req.Password)
	if !passwordResult.Valid {
		errorDetails := "Password requirements not met"
		if len(passwordResult.Errors) > 0 {
			errorDetails = passwordResult.Errors[0]
		}

		logger.Warn("password validation failed",
			"email", email,
			"strength", passwordResult.Strength,
			"error_count", len(passwordResult.Errors))

		sysdatastores.AddActivityLog(ApiTypes.ActivityLogDef{
			ActivityName: ApiTypes.ActivityName_Auth,
			ActivityType: ApiTypes.ActivityType_WeakPassword,
			AppName:      ApiTypes.AppName_Auth,
			ModuleName:   ApiTypes.ModuleName_EmailAuth,
			ActivityMsg:  &errorDetails,
			CallerLoc:    "SHD_0207180105",
		})

		return http.StatusBadRequest, KratosSignupResponse{
			Status:  "error",
			Message: errorDetails,
			LOC:     "SHD_0207180106",
		}
	}

	ctx := context.Background()

	// Step 1: Create a native registration flow
	regFlow, resp, err := kratosClient.client.FrontendAPI.CreateNativeRegistrationFlow(ctx).Execute()
	if err != nil {
		logger.Error("Failed to create registration flow", "error", err)
		if resp != nil {
			logger.Error("Kratos response", "status", resp.StatusCode)
		}

		return http.StatusInternalServerError, KratosSignupResponse{
			Status:  "error",
			Message: "Failed to initialize registration",
			LOC:     "SHD_0207180107",
		}
	}

	flowID := regFlow.Id
	logger.Info("Created registration flow", "flow_id", flowID)

	// Step 2: Build the traits for Kratos
	traits := map[string]interface{}{
		"email": email,
	}
	if firstName != "" || lastName != "" {
		traits["name"] = map[string]interface{}{
			"first": firstName,
			"last":  lastName,
		}
	}

	// Step 3: Submit the registration credentials to Kratos
	updateRegFlowBody := ory.UpdateRegistrationFlowBody{
		UpdateRegistrationFlowWithPasswordMethod: &ory.UpdateRegistrationFlowWithPasswordMethod{
			Method:   "password",
			Password: req.Password,
			Traits:   traits,
		},
	}

	successfulReg, resp, err := kratosClient.client.FrontendAPI.UpdateRegistrationFlow(ctx).
		Flow(flowID).
		UpdateRegistrationFlowBody(updateRegFlowBody).
		Execute()

	if err != nil {
		logger.Error("Registration failed", "email", email, "error", err)

		// Parse Kratos error response for better error messages
		errorMessage := "Registration failed"
		if resp != nil {
			if respBody, readErr := io.ReadAll(resp.Body); readErr == nil {
				var kratosError map[string]interface{}
				if jsonErr := json.Unmarshal(respBody, &kratosError); jsonErr == nil {
					// Check for UI messages (validation errors)
					if ui, ok := kratosError["ui"].(map[string]interface{}); ok {
						if messages, ok := ui["messages"].([]interface{}); ok && len(messages) > 0 {
							if msg, ok := messages[0].(map[string]interface{}); ok {
								if text, ok := msg["text"].(string); ok {
									errorMessage = text
								}
							}
						}
						// Also check for node-level errors (field validation)
						if nodes, ok := ui["nodes"].([]interface{}); ok {
							for _, node := range nodes {
								if n, ok := node.(map[string]interface{}); ok {
									if msgs, ok := n["messages"].([]interface{}); ok && len(msgs) > 0 {
										if m, ok := msgs[0].(map[string]interface{}); ok {
											if text, ok := m["text"].(string); ok && text != "" {
												errorMessage = text
												break
											}
										}
									}
								}
							}
						}
					}
					// Check for generic error message
					if errMsg, ok := kratosError["error"].(map[string]interface{}); ok {
						if message, ok := errMsg["message"].(string); ok {
							errorMessage = message
						}
					}
				}
			}
		}

		sysdatastores.AddActivityLog(ApiTypes.ActivityLogDef{
			ActivityName: ApiTypes.ActivityName_Auth,
			ActivityType: ApiTypes.ActivityType_AuthFailure,
			AppName:      ApiTypes.AppName_Auth,
			ModuleName:   ApiTypes.ModuleName_EmailAuth,
			ActivityMsg:  func() *string { s := fmt.Sprintf("Registration failed: %s, error: %s", email, errorMessage); return &s }(),
			CallerLoc:    "SHD_0207180108",
		})

		// Handle specific error codes
		statusCode := http.StatusBadRequest
		if resp != nil && resp.StatusCode == http.StatusConflict {
			errorMessage = "An account with this email already exists"
			statusCode = http.StatusConflict
		}

		return statusCode, KratosSignupResponse{
			Status:  "error",
			Message: errorMessage,
			LOC:     "SHD_0211103020",
		}
	}

	// Success! Check if we got a session (auto-login enabled) or need verification
	logger.Info("Registration flow completed", "email", email)

	// Check if Kratos returned a session (auto-login after registration)
	if successfulReg.Session != nil {
		session := successfulReg.Session
		identity := session.Identity
		traitsMap := identity.Traits.(map[string]interface{})

		// Extract user info
		var regFirstName, regLastName string
		if name, ok := traitsMap["name"].(map[string]interface{}); ok {
			if first, ok := name["first"].(string); ok {
				regFirstName = first
			}
			if last, ok := name["last"].(string); ok {
				regLastName = last
			}
		}

		isAdmin := false
		isOwner := false
		if identity.MetadataPublic != nil {
			if admin, ok := identity.MetadataPublic["admin"].(bool); ok {
				isAdmin = admin
			}
			if owner, ok := identity.MetadataPublic["is_owner"].(bool); ok {
				isOwner = owner
			}
		}

		// Set the session token as a cookie (using custom cookie name for native flow tokens)
		if successfulReg.SessionToken != nil {
			sessionToken := *successfulReg.SessionToken
			expiredTime := time.Now().Add(cookie_timeout_hours * time.Hour)

			cookie := &http.Cookie{
				Name:     "session_token",
				Value:    sessionToken,
				Path:     "/",
				Expires:  expiredTime,
				HttpOnly: true,
				Secure:   true,
				SameSite: http.SameSiteLaxMode,
			}
			c.SetCookie(cookie)

			// Log the session
			customLayout := "2006-01-02 15:04:05"
			expiredTimeStr := expiredTime.Format(customLayout)

			sysdatastores.AddSessionLog(sysdatastores.SessionLogDef{
				LoginMethod:  "kratos_signup",
				SessionID:    session.Id,
				AuthToken:    ApiUtils.MaskToken(sessionToken),
				Status:       "active",
				UserName:     email,
				UserNameType: "email",
				UserRegID:    identity.Id,
				UserEmail:    &email,
				CallerLoc:    "SHD_0207180109",
				ExpiresAt:    &expiredTimeStr,
			})
		}

		msg := fmt.Sprintf("Kratos signup success with session, email:%s, identity_id:%s",
			email, identity.Id)
		sysdatastores.AddActivityLog(ApiTypes.ActivityLogDef{
			ActivityName: ApiTypes.ActivityName_Auth,
			ActivityType: ApiTypes.ActivityType_SignupSuccess,
			AppName:      ApiTypes.AppName_Auth,
			ModuleName:   ApiTypes.ModuleName_EmailAuth,
			ActivityMsg:  &msg,
			CallerLoc:    "SHD_0207180110",
		})

		logger.Info("Kratos signup success with auto-login",
			"email", email,
			"identity_id", identity.Id,
			"session_id", session.Id)

		redirectURL := GetRedirectURL(rc, email, isAdmin, false)

		// Extract verification flow ID from Kratos continue_with
		var verificationFlowID string
		for _, cw := range successfulReg.ContinueWith {
			if cw.ContinueWithVerificationUi != nil {
				verificationFlowID = cw.ContinueWithVerificationUi.Flow.Id
				logger.Info("Verification flow ID extracted", "flow_id", verificationFlowID)
				break
			}
		}

		return http.StatusOK, KratosSignupResponse{
			Status:             "ok",
			Message:            "Registration successful",
			RedirectURL:        redirectURL,
			VerificationFlowID: verificationFlowID,
			LOC:                "SHD_0211103021",
			Session: map[string]interface{}{
				"id":               session.Id,
				"active":           session.Active,
				"expires_at":       session.ExpiresAt,
				"authenticated_at": session.AuthenticatedAt,
				"identity": map[string]interface{}{
					"id": identity.Id,
					"traits": map[string]interface{}{
						"email": email,
						"name": map[string]interface{}{
							"first": regFirstName,
							"last":  regLastName,
						},
					},
					"metadata_public": map[string]interface{}{
						"admin":    isAdmin,
						"is_owner": isOwner,
					},
					"created_at": identity.CreatedAt,
					"updated_at": identity.UpdatedAt,
				},
			},
		}
	}

	// No session returned - verification email will be sent by Kratos
	// (based on Kratos configuration for email verification)
	msg := fmt.Sprintf("Kratos signup success (pending verification), email:%s, identity_id:%s",
		email, successfulReg.Identity.Id)
	sysdatastores.AddActivityLog(ApiTypes.ActivityLogDef{
		ActivityName: ApiTypes.ActivityName_Auth,
		ActivityType: ApiTypes.ActivityType_SignupSuccess,
		AppName:      ApiTypes.AppName_Auth,
		ModuleName:   ApiTypes.ModuleName_EmailAuth,
		ActivityMsg:  &msg,
		CallerLoc:    "SHD_0207180100",
	})

	logger.Info("Kratos signup success (verification pending)",
		"email", email,
		"identity_id", successfulReg.Identity.Id)

	return http.StatusOK, KratosSignupResponse{
		Status:  "ok",
		Message: "Registration successful! Please check your email to verify your account.",
		LOC:     "SHD_0207180101",
	}
}

// IsAuthenticatedKratos checks if the request has a valid Kratos session.
// Returns the user info if authenticated, nil otherwise.
func IsAuthenticatedKratos(rc ApiTypes.RequestContext, c echo.Context) (*ApiTypes.UserInfo, error) {
	logger := rc.GetLogger()

	if kratosClient == nil {
		InitKratosClient()
	}

	session, err := kratosClient.ValidateSession(c)
	if err != nil {
		logger.Info("Kratos session validation failed", "error", err)
		return nil, err
	}

	identity := session.Identity
	traits := identity.Traits.(map[string]interface{})
	email := traits["email"].(string)

	var firstName, lastName string
	if name, ok := traits["name"].(map[string]interface{}); ok {
		if first, ok := name["first"].(string); ok {
			firstName = first
		}
		if last, ok := name["last"].(string); ok {
			lastName = last
		}
	}

	isAdmin := false
	isOwner := false
	avatarAuth := ""
	if identity.MetadataPublic != nil {
		if admin, ok := identity.MetadataPublic["admin"].(bool); ok {
			isAdmin = admin
		}
		if owner, ok := identity.MetadataPublic["is_owner"].(bool); ok {
			isOwner = owner
		}
		if av, ok := identity.MetadataPublic["avatar"].(string); ok {
			avatarAuth = av
		}
	}

	userStatus := "active"
	if identity.State != nil {
		userStatus = string(*identity.State)
	}

	userInfo := &ApiTypes.UserInfo{
		UserId:     identity.Id,
		UserName:   email,
		Email:      email,
		FirstName:  firstName,
		LastName:   lastName,
		Admin:      isAdmin,
		IsOwner:    isOwner,
		Avatar:     avatarAuth,
		UserStatus: userStatus,
		Verified:   true, // Kratos sessions imply verified
		AuthType:   "kratos",
	}

	logger.Info("Kratos session valid",
		"email", email,
		"identity_id", identity.Id,
		"is_admin", isAdmin,
		"is_owner", isOwner)

	return userInfo, nil
}

// IsAuthenticatedKratosFromRC validates a Kratos session using only RequestContext
// (no echo.Context required). This is used by authmiddleware.KratosAuthenticator
// to validate Kratos sessions as a fallback when the old session_id cookie is not found.
func IsAuthenticatedKratosFromRC(rc ApiTypes.RequestContext) (*ApiTypes.UserInfo, error) {
	logger := rc.GetLogger()

	if kratosClient == nil {
		InitKratosClient()
	}

	req := rc.GetRequest()
	if req == nil {
		return nil, fmt.Errorf("no HTTP request available (SHD_0211100100)")
	}

	cookies := req.Header.Get("Cookie")
	sessionToken := req.Header.Get("X-Session-Token")

	// Check for session_token cookie if no X-Session-Token header
	if sessionToken == "" {
		if cookie, err := req.Cookie("session_token"); err == nil && cookie.Value != "" {
			sessionToken = cookie.Value
		}
	}

	ctx := context.Background()
	toSessionReq := kratosClient.client.FrontendAPI.ToSession(ctx)
	if cookies != "" {
		toSessionReq = toSessionReq.Cookie(cookies)
	}
	if sessionToken != "" {
		toSessionReq = toSessionReq.XSessionToken(sessionToken)
	}

	session, _, err := toSessionReq.Execute()
	if err != nil {
		logger.Info("Kratos session validation failed (RC)", "error", err)
		return nil, err
	}

	identity := session.Identity
	traits := identity.Traits.(map[string]interface{})
	email := traits["email"].(string)

	var firstName, lastName string
	if name, ok := traits["name"].(map[string]interface{}); ok {
		if first, ok := name["first"].(string); ok {
			firstName = first
		}
		if last, ok := name["last"].(string); ok {
			lastName = last
		}
	}

	isAdmin := false
	isOwner := false
	avatarRC := ""
	if identity.MetadataPublic != nil {
		if admin, ok := identity.MetadataPublic["admin"].(bool); ok {
			isAdmin = admin
		}
		if owner, ok := identity.MetadataPublic["is_owner"].(bool); ok {
			isOwner = owner
		}
		if av, ok := identity.MetadataPublic["avatar"].(string); ok {
			avatarRC = av
		}
	}

	userStatusRC := "active"
	if identity.State != nil {
		userStatusRC = string(*identity.State)
	}

	userInfo := &ApiTypes.UserInfo{
		UserId:     identity.Id,
		UserName:   email,
		Email:      email,
		FirstName:  firstName,
		LastName:   lastName,
		Admin:      isAdmin,
		IsOwner:    isOwner,
		Avatar:     avatarRC,
		UserStatus: userStatusRC,
		Verified:   true,
		AuthType:   "kratos",
	}

	logger.Info("Kratos session valid (RC)",
		"email", email,
		"identity_id", identity.Id,
		"is_admin", isAdmin,
		"is_owner", isOwner)

	return userInfo, nil
}

// KratosTOTPRequest represents the TOTP verification request body
type KratosTOTPRequest struct {
	Code string `json:"code"`
}

// HandleGoogleLoginKratos initiates Google OAuth login via Kratos OIDC.
// This serves an HTML page that auto-submits a form to Kratos, ensuring
// the browser receives Kratos's cookies directly and provides a seamless
// redirect to Google without showing the Kratos UI.
//
// Flow:
//  1. Browser requests /auth/google/login
//  2. Go backend fetches a login flow from Kratos (server-side)
//  3. Go backend returns HTML with auto-submitting form
//  4. Browser submits form directly to Kratos with method=oidc, provider=google
//  5. Kratos sets cookies in browser, redirects to Google
//  6. User authenticates with Google
//  7. Google redirects to Kratos callback (browser has cookies)
//  8. Kratos validates, creates session, redirects to return_to
func HandleGoogleLoginKratos(c echo.Context) error {
	rc := EchoFactory.NewFromEcho(c, "SHD_0211103022")
	defer rc.Close()
	logger := rc.GetLogger()

	logger.Info("HandleGoogleLoginKratos called")

	kratosURL := os.Getenv("KRATOS_PUBLIC_URL")
	if kratosURL == "" {
		logger.Error("KRATOS_PUBLIC_URL not set, defaulting to http://localhost:4433")
		kratosURL = "http://localhost:4433"
	}

	// Get the frontend base URL for OAuth callback
	frontendURL := os.Getenv("APP_BASE_URL")
	if frontendURL == "" {
		logger.Error("APP_BASE_URL not set, defaulting to http://localhost:8080")
		frontendURL = "http://localhost:8080"
	}

	// Get the user's intended destination after login (optional)
	// This will be passed to the OAuth callback for final redirect
	userReturnURL := c.QueryParam("returnUrl")

	// Build the OAuth callback URL - this is where Kratos will redirect after successful login
	// The callback page will then redirect to the appropriate dashboard based on user's role
	callbackURL := fmt.Sprintf("%s/oauth/callback", strings.TrimSuffix(frontendURL, "/"))
	if userReturnURL != "" {
		// Validate the user's return URL for security (can be relative or absolute)
		if ApiUtils.IsSafeReturnURL(userReturnURL) || ApiUtils.IsSafeAbsoluteReturnURL(userReturnURL) {
			callbackURL = fmt.Sprintf("%s?returnUrl=%s", callbackURL, url.QueryEscape(userReturnURL))
		} else {
			logger.Warn("Rejected unsafe returnUrl", "returnUrl", userReturnURL)
		}
	}

	// The return_to URL for Kratos is our OAuth callback endpoint
	returnURL := callbackURL

	// Step 1: Create a browser login flow (server-side) to get the flow ID and action URL
	loginFlowURL := fmt.Sprintf("%s/self-service/login/browser?return_to=%s",
		kratosURL, url.QueryEscape(returnURL))

	httpClient := &http.Client{
		Timeout: 10 * time.Second,
		CheckRedirect: func(req *http.Request, via []*http.Request) error {
			return http.ErrUseLastResponse
		},
	}

	req, err := http.NewRequestWithContext(context.Background(), "GET", loginFlowURL, nil)
	if err != nil {
		logger.Error("Failed to create request", "error", err)
		return c.String(http.StatusInternalServerError, "Failed to initialize login")
	}
	req.Header.Set("Accept", "application/json")

	resp, err := httpClient.Do(req)
	if err != nil {
		logger.Error("Failed to create login flow", "error", err)
		return c.String(http.StatusInternalServerError, "Failed to connect to authentication service")
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		logger.Error("Failed to read response", "error", err)
		return c.String(http.StatusInternalServerError, "Failed to read authentication response")
	}

	// Parse the login flow response
	var loginFlow map[string]interface{}
	if err := json.Unmarshal(body, &loginFlow); err != nil {
		logger.Error("Failed to parse login flow", "error", err, "body", string(body))
		return c.String(http.StatusInternalServerError, "Failed to parse authentication response")
	}

	flowID, ok := loginFlow["id"].(string)
	if !ok || flowID == "" {
		logger.Error("No flow ID in response", "response", string(body))
		return c.String(http.StatusInternalServerError, "Invalid authentication response")
	}

	// Get the action URL from the flow's UI
	actionURL := fmt.Sprintf("%s/self-service/login?flow=%s", kratosURL, flowID)
	if ui, ok := loginFlow["ui"].(map[string]interface{}); ok {
		if action, ok := ui["action"].(string); ok && action != "" {
			actionURL = action
		}
	}

	// Get CSRF token from the flow
	csrfToken := ""
	if ui, ok := loginFlow["ui"].(map[string]interface{}); ok {
		if nodes, ok := ui["nodes"].([]interface{}); ok {
			for _, node := range nodes {
				if n, ok := node.(map[string]interface{}); ok {
					if attrs, ok := n["attributes"].(map[string]interface{}); ok {
						if name, ok := attrs["name"].(string); ok && name == "csrf_token" {
							if value, ok := attrs["value"].(string); ok {
								csrfToken = value
								break
							}
						}
					}
				}
			}
		}
	}

	logger.Info("Created login flow for Google OIDC",
		"flow_id", flowID,
		"action_url", actionURL,
		"has_csrf", csrfToken != "")

	// Forward any cookies from Kratos to the browser
	// This is critical - the browser needs the CSRF cookie
	for _, cookie := range resp.Cookies() {
		c.SetCookie(&http.Cookie{
			Name:     cookie.Name,
			Value:    cookie.Value,
			Path:     cookie.Path,
			Domain:   cookie.Domain,
			Expires:  cookie.Expires,
			MaxAge:   cookie.MaxAge,
			Secure:   cookie.Secure,
			HttpOnly: cookie.HttpOnly,
			SameSite: cookie.SameSite,
		})
	}

	// Step 2: Return an HTML page that auto-submits to Kratos
	// This ensures the browser POSTs directly to Kratos and receives cookies
	html := fmt.Sprintf(`<!DOCTYPE html>
<html>
<head>
    <title>Redirecting to Google...</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f5f5f5;
        }
        .loading {
            text-align: center;
        }
        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #e0e0e0;
            border-top: 4px solid #4285f4;
            border-radius: 50%%;
            animation: spin 1s linear infinite;
            margin: 0 auto 16px;
        }
        @keyframes spin {
            0%% { transform: rotate(0deg); }
            100%% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="loading">
        <div class="spinner"></div>
        <p>Redirecting to Google...</p>
    </div>
    <form id="oidc-form" action="%s" method="POST" style="display:none;">
        <input type="hidden" name="csrf_token" value="%s">
        <input type="hidden" name="method" value="oidc">
        <input type="hidden" name="provider" value="google">
    </form>
    <script>
        document.getElementById('oidc-form').submit();
    </script>
</body>
</html>`, actionURL, csrfToken)

	return c.HTML(http.StatusOK, html)
}

// PasswordResetTokenExpiry is the expiry for password reset JWT tokens (1 hour).
const PasswordResetTokenExpiry = 1 * time.Hour

// HandleForgotPasswordKratos handles forgot password requests when Kratos is enabled.
// Instead of storing tokens in the old users table, it:
// 1. Looks up the identity in Kratos by email via Admin API
// 2. Generates a JWT token containing email and identity_id
// 3. Sends a password reset email with the JWT token
func HandleForgotPasswordKratos(c echo.Context) error {
	rc := EchoFactory.NewFromEcho(c, "SHD_0211103023")
	defer rc.Close()
	logger := rc.GetLogger()

	// SECURITY: Rate limiting to prevent abuse
	clientIP := c.RealIP()
	allowed, _, retryAfter := CheckPasswordResetRateLimit(clientIP)
	if !allowed {
		logger.Warn("Rate limit exceeded for password reset", "ip", clientIP)
		return c.JSON(http.StatusTooManyRequests, map[string]string{
			"status":  "error",
			"message": "Too many password reset attempts. Please try again later.",
			"loc":     "SHD_0211103024",
		})
	}
	_ = retryAfter

	// SECURITY: Validate request origin to prevent CSRF attacks
	if !IsSafeOrigin(c) {
		logger.Warn("CSRF protection: rejected cross-origin request",
			"origin", c.Request().Header.Get("Origin"),
			"referer", c.Request().Header.Get("Referer"))
		return c.JSON(http.StatusForbidden, map[string]string{
			"status":  "error",
			"message": "Invalid request origin",
			"loc":     "SHD_0211103025",
		})
	}

	var req struct {
		Email string `json:"email"`
	}
	if err := c.Bind(&req); err != nil {
		logger.Error("invalid request body", "error", err)
		return c.JSON(http.StatusBadRequest, map[string]string{
			"status":  "error",
			"message": "Invalid request body",
			"loc":     "SHD_0211103026",
		})
	}

	if !isValidEmail(req.Email) {
		logger.Warn("invalid email format", "email", req.Email)
		return c.JSON(http.StatusBadRequest, map[string]string{
			"status":  "error",
			"message": "Invalid email format",
			"loc":     "SHD_0211103027",
		})
	}

	// SECURITY: Always return success to prevent user enumeration
	successMsg := "If an account exists with this email, a password reset link has been sent."

	if kratosClient == nil {
		InitKratosClient()
	}

	// Look up identity in Kratos by email via Admin API
	adminURL := os.Getenv("KRATOS_ADMIN_URL")
	if adminURL == "" {
		adminURL = "http://localhost:4434"
	}

	ctx := context.Background()
	httpClient := &http.Client{Timeout: 10 * time.Second}
	adminReq, err := http.NewRequestWithContext(ctx, "GET",
		fmt.Sprintf("%s/admin/identities?credentials_identifier=%s", adminURL, url.QueryEscape(req.Email)), nil)
	if err != nil {
		logger.Error("Failed to create admin request", "error", err)
		// Return success to prevent enumeration
		return c.JSON(http.StatusOK, map[string]string{
			"status":  "ok",
			"message": successMsg,
			"loc":     "SHD_0211103028",
		})
	}
	adminReq.Header.Set("Accept", "application/json")

	adminResp, err := httpClient.Do(adminReq)
	if err != nil {
		logger.Error("Failed to query Kratos Admin API", "error", err)
		return c.JSON(http.StatusOK, map[string]string{
			"status":  "ok",
			"message": successMsg,
			"loc":     "SHD_0211103029",
		})
	}
	defer adminResp.Body.Close()

	respBody, _ := io.ReadAll(adminResp.Body)
	if adminResp.StatusCode != http.StatusOK {
		logger.Error("Kratos Admin API error", "status", adminResp.StatusCode, "body", string(respBody))
		return c.JSON(http.StatusOK, map[string]string{
			"status":  "ok",
			"message": successMsg,
			"loc":     "SHD_0211103030",
		})
	}

	var identities []ory.Identity
	if err := json.Unmarshal(respBody, &identities); err != nil || len(identities) == 0 {
		// User not found in Kratos - return success to prevent enumeration
		logger.Warn("No identity found for email (or parse error)", "email", req.Email, "error", err)

		sysdatastores.AddActivityLog(ApiTypes.ActivityLogDef{
			ActivityName: ApiTypes.ActivityName_Auth,
			ActivityType: ApiTypes.ActivityType_UserNotFound,
			AppName:      ApiTypes.AppName_Auth,
			ModuleName:   ApiTypes.ModuleName_EmailAuth,
			ActivityMsg: func() *string {
				s := fmt.Sprintf("Password reset for non-existent Kratos identity: %s", req.Email)
				return &s
			}(),
			CallerLoc: "SHD_0211103031",
		})

		return c.JSON(http.StatusOK, map[string]string{
			"status":  "ok",
			"message": successMsg,
			"loc":     "SHD_0211103032",
		})
	}

	identity := identities[0]

	// Generate a JWT token containing the email and identity ID
	token, err := GenerateToken(map[string]interface{}{
		"email":       req.Email,
		"identity_id": identity.Id,
		"purpose":     "password_reset",
	}, PasswordResetTokenExpiry)
	if err != nil {
		logger.Error("Failed to generate reset token", "error", err)
		return c.JSON(http.StatusInternalServerError, map[string]string{
			"status":  "error",
			"message": "Failed to process request",
			"loc":     "SHD_0211103033",
		})
	}

	// Send reset email
	homeDomain := os.Getenv("APP_BASE_URL")
	if homeDomain == "" {
		logger.Error("APP_BASE_URL not set")
		return c.JSON(http.StatusInternalServerError, map[string]string{
			"status":  "error",
			"message": "Server configuration error",
			"loc":     "SHD_0211103034",
		})
	}

	// Get display name from traits
	displayName := req.Email
	if identity.Traits != nil {
		if traits, ok := identity.Traits.(map[string]interface{}); ok {
			if name, ok := traits["name"].(map[string]interface{}); ok {
				if first, ok := name["first"].(string); ok && first != "" {
					displayName = first
				}
			}
		}
	}

	resetURL := fmt.Sprintf("%s/reset-password?token=%s", homeDomain, token)
	htmlBody := fmt.Sprintf(`
		<p>Hi %s,</p>
		<p>Click the link below to reset your password:</p>
		<p><a href="%s">%s</a></p>
		<p>This link will expire in 1 hour.</p>
	`, displayName, resetURL, resetURL)
	textBody := fmt.Sprintf("Hi %s,\n\nClick the link below to reset your password:\n%s\n\nThis link will expire in 1 hour.", displayName, resetURL)

	go ApiUtils.SendMail(rc, req.Email, "Password Reset", textBody, htmlBody, ApiUtils.EmailTypePasswordReset)

	logger.Info("Password reset email sent (Kratos)", "email", req.Email)

	sysdatastores.AddActivityLog(ApiTypes.ActivityLogDef{
		ActivityName: ApiTypes.ActivityName_Auth,
		ActivityType: ApiTypes.ActivityType_SentEmail,
		AppName:      ApiTypes.AppName_Auth,
		ModuleName:   ApiTypes.ModuleName_EmailAuth,
		ActivityMsg:  func() *string { s := fmt.Sprintf("Kratos password reset email sent to: %s", req.Email); return &s }(),
		CallerLoc:    "SHD_0211103035",
	})

	return c.JSON(http.StatusOK, map[string]string{
		"status":  "ok",
		"message": successMsg,
		"loc":     "SHD_0211103036",
	})
}

// HandleResetLinkKratos handles the GET request when user clicks the password
// reset link in their email. It validates the JWT token and redirects to
// the frontend reset password page.
func HandleResetLinkKratos(c echo.Context) error {
	rc := EchoFactory.NewFromEcho(c, "SHD_0211103037")
	defer rc.Close()
	logger := rc.GetLogger()

	token := c.QueryParam("token")
	if token == "" {
		return c.String(http.StatusBadRequest, "Missing reset token")
	}

	// Validate the JWT token
	claims, err := ParseToken(token)
	if err != nil {
		logger.Warn("Invalid reset token", "error", err)
		return c.String(http.StatusBadRequest, "Invalid or expired reset link (SHD_0211103038).")
	}

	// Verify this is a password reset token
	purpose, _ := claims["purpose"].(string)
	if purpose != "password_reset" {
		logger.Warn("Token is not a password reset token", "purpose", purpose)
		return c.String(http.StatusBadRequest, "Invalid reset link (SHD_0211103039).")
	}

	// Redirect to frontend reset form
	homeDomain := os.Getenv("APP_BASE_URL")
	if homeDomain == "" {
		logger.Error("APP_BASE_URL not set")
	}
	redirectURL := fmt.Sprintf("%s/reset-password?token=%s", homeDomain, token)

	sysdatastores.AddActivityLog(ApiTypes.ActivityLogDef{
		ActivityName: ApiTypes.ActivityName_Auth,
		ActivityType: ApiTypes.ActivityType_Redirect,
		AppName:      ApiTypes.AppName_Auth,
		ModuleName:   ApiTypes.ModuleName_EmailAuth,
		ActivityMsg:  func() *string { s := fmt.Sprintf("Kratos reset link redirect to: %s", redirectURL); return &s }(),
		CallerLoc:    "SHD_0211103040",
	})

	return c.Redirect(http.StatusSeeOther, redirectURL)
}

// HandleResetPasswordConfirmKratos handles the password reset confirmation
// when Kratos is enabled. It validates the JWT token and updates the password
// in Kratos via the Admin API.
func HandleResetPasswordConfirmKratos(c echo.Context) error {
	rc := EchoFactory.NewFromEcho(c, "SHD_0211103041")
	defer rc.Close()
	logger := rc.GetLogger()

	// SECURITY: Validate request origin to prevent CSRF attacks
	if !IsSafeOrigin(c) {
		logger.Warn("CSRF protection: rejected cross-origin request",
			"origin", c.Request().Header.Get("Origin"),
			"referer", c.Request().Header.Get("Referer"))
		return c.String(http.StatusForbidden, "Invalid request origin")
	}

	// Parse request body
	var req ResetConfirmRequest
	if err := json.NewDecoder(c.Request().Body).Decode(&req); err != nil {
		logger.Error("Invalid request payload", "error", err)
		return c.String(http.StatusBadRequest, "Invalid request payload (SHD_0211103042).")
	}

	// Validate the JWT token
	claims, err := ParseToken(req.Token)
	if err != nil {
		logger.Warn("Invalid reset token", "error", err)
		return c.String(http.StatusBadRequest, "Invalid or expired reset token (SHD_0211103043).")
	}

	// Verify this is a password reset token
	purpose, _ := claims["purpose"].(string)
	if purpose != "password_reset" {
		logger.Warn("Token is not a password reset token", "purpose", purpose)
		return c.String(http.StatusBadRequest, "Invalid reset token (SHD_0211103044).")
	}

	email, _ := claims["email"].(string)
	identityID, _ := claims["identity_id"].(string)
	if email == "" || identityID == "" {
		logger.Error("Token missing required claims", "email", email, "identity_id", identityID)
		return c.String(http.StatusBadRequest, "Invalid reset token (SHD_0211103045).")
	}

	// SECURITY: Validate password strength
	passwordResult := ValidatePasswordDefault(req.Password)
	if !passwordResult.Valid {
		errorDetails := "Password requirements not met"
		if len(passwordResult.Errors) > 0 {
			errorDetails = passwordResult.Errors[0]
		}
		logger.Warn("Password validation failed", "email", email)
		return c.String(http.StatusBadRequest, errorDetails)
	}

	// Update the password in Kratos via Admin API
	adminURL := os.Getenv("KRATOS_ADMIN_URL")
	if adminURL == "" {
		adminURL = "http://localhost:4434"
	}

	// Step 1: Get current identity to preserve traits
	ctx := context.Background()
	httpClient := &http.Client{Timeout: 10 * time.Second}

	getReq, err := http.NewRequestWithContext(ctx, "GET",
		fmt.Sprintf("%s/admin/identities/%s", adminURL, identityID), nil)
	if err != nil {
		logger.Error("Failed to create get identity request", "error", err)
		return c.String(http.StatusInternalServerError, "Failed to process request (SHD_0211103046).")
	}
	getReq.Header.Set("Accept", "application/json")

	getResp, err := httpClient.Do(getReq)
	if err != nil {
		logger.Error("Failed to get identity from Kratos", "error", err)
		return c.String(http.StatusInternalServerError, "Failed to process request (SHD_0211103047).")
	}
	defer getResp.Body.Close()

	getBody, _ := io.ReadAll(getResp.Body)
	if getResp.StatusCode != http.StatusOK {
		logger.Error("Kratos Admin API error getting identity",
			"status", getResp.StatusCode, "body", string(getBody))
		return c.String(http.StatusInternalServerError, "Failed to process request (SHD_0211103048).")
	}

	var currentIdentity map[string]interface{}
	if err := json.Unmarshal(getBody, &currentIdentity); err != nil {
		logger.Error("Failed to parse identity", "error", err)
		return c.String(http.StatusInternalServerError, "Failed to process request (SHD_0211103049).")
	}

	// Step 2: Update the identity with the new password
	updateBody := map[string]interface{}{
		"schema_id": currentIdentity["schema_id"],
		"state":     "active",
		"traits":    currentIdentity["traits"],
		"credentials": map[string]interface{}{
			"password": map[string]interface{}{
				"config": map[string]interface{}{
					"password": req.Password,
				},
			},
		},
	}

	// Preserve metadata if present
	if mp, ok := currentIdentity["metadata_public"]; ok && mp != nil {
		updateBody["metadata_public"] = mp
	}
	if ma, ok := currentIdentity["metadata_admin"]; ok && ma != nil {
		updateBody["metadata_admin"] = ma
	}

	updateJSON, err := json.Marshal(updateBody)
	if err != nil {
		logger.Error("Failed to marshal update body", "error", err)
		return c.String(http.StatusInternalServerError, "Failed to process request (SHD_0211103050).")
	}

	putReq, err := http.NewRequestWithContext(ctx, "PUT",
		fmt.Sprintf("%s/admin/identities/%s", adminURL, identityID),
		strings.NewReader(string(updateJSON)))
	if err != nil {
		logger.Error("Failed to create update request", "error", err)
		return c.String(http.StatusInternalServerError, "Failed to process request (SHD_0211103051).")
	}
	putReq.Header.Set("Content-Type", "application/json")
	putReq.Header.Set("Accept", "application/json")

	putResp, err := httpClient.Do(putReq)
	if err != nil {
		logger.Error("Failed to update identity in Kratos", "error", err)
		return c.String(http.StatusInternalServerError, "Failed to update password (SHD_0211103052).")
	}
	defer putResp.Body.Close()

	putBody, _ := io.ReadAll(putResp.Body)
	if putResp.StatusCode != http.StatusOK {
		logger.Error("Kratos Admin API error updating identity",
			"status", putResp.StatusCode, "body", string(putBody))
		return c.String(http.StatusInternalServerError, "Failed to update password (SHD_0211103053).")
	}

	logger.Info("Password reset successful via Kratos Admin API",
		"email", email, "identity_id", identityID)

	sysdatastores.AddActivityLog(ApiTypes.ActivityLogDef{
		ActivityName: ApiTypes.ActivityName_Auth,
		ActivityType: ApiTypes.ActivityType_UserLoginSuccess,
		AppName:      ApiTypes.AppName_Auth,
		ModuleName:   ApiTypes.ModuleName_EmailAuth,
		ActivityMsg:  func() *string { s := fmt.Sprintf("Kratos password reset success, email:%s", email); return &s }(),
		CallerLoc:    "SHD_0211103054",
	})

	return c.String(http.StatusOK, "Password has been reset successfully.")
}

// HandleTOTPVerifyKratos handles TOTP verification to upgrade session from AAL1 to AAL2.
// This is called after successful password login when user has 2FA configured.
//
// Flow:
//  1. User has already authenticated with password (AAL1 session exists via cookie)
//  2. Create a login flow with aal=aal2 to request second factor
//  3. Submit the TOTP code to complete 2FA
//  4. Session is upgraded to AAL2
func HandleTOTPVerifyKratos(c echo.Context) error {
	rc := EchoFactory.NewFromEcho(c, "SHD_0211103055")
	defer rc.Close()
	logger := rc.GetLogger()

	logger.Info("HandleTOTPVerifyKratos called")

	// SECURITY: Validate request origin to prevent CSRF attacks
	if !IsSafeOrigin(c) {
		logger.Warn("CSRF protection: rejected cross-origin request",
			"origin", c.Request().Header.Get("Origin"),
			"referer", c.Request().Header.Get("Referer"))
		return c.JSON(http.StatusForbidden, map[string]interface{}{
			"status":  "error",
			"message": "Invalid request origin",
			"LOC":     "SHD_02111030056",
		})
	}

	if kratosClient == nil {
		InitKratosClient()
	}

	// Parse the TOTP code from request
	var req KratosTOTPRequest
	if err := c.Bind(&req); err != nil {
		logger.Error("Failed to parse TOTP request", "error", err)
		return c.JSON(http.StatusBadRequest, map[string]interface{}{
			"status":  "error",
			"message": "Invalid request body",
			"LOC":     "SHD_02111030057",
		})
	}

	if req.Code == "" {
		return c.JSON(http.StatusBadRequest, map[string]interface{}{
			"status":  "error",
			"message": "TOTP code is required",
			"LOC":     "SHD_02111030058",
		})
	}

	// Get the session token from cookie (set during AAL1 login)
	sessionToken := ""
	if cookie, err := c.Cookie("session_token"); err == nil && cookie.Value != "" {
		sessionToken = cookie.Value
	}

	if sessionToken == "" {
		logger.Warn("No session token found for 2FA verification")
		return c.JSON(http.StatusUnauthorized, map[string]interface{}{
			"status":  "error",
			"message": "No active session. Please login again.",
			"LOC":     "SHD_02111030059",
		})
	}

	ctx := context.Background()

	// Step 1: Create a login flow with aal=aal2 to request second factor
	// This tells Kratos we want to upgrade the session to AAL2
	loginFlow, resp, err := kratosClient.client.FrontendAPI.CreateNativeLoginFlow(ctx).
		Aal("aal2").
		XSessionToken(sessionToken).
		Execute()

	if err != nil {
		logger.Error("Failed to create AAL2 login flow", "error", err)
		if resp != nil {
			logger.Error("Kratos response", "status", resp.StatusCode)
		}
		return c.JSON(http.StatusInternalServerError, map[string]interface{}{
			"status":  "error",
			"message": "Failed to initialize 2FA verification",
			"LOC":     "SHD_02111030060",
		})
	}

	flowID := loginFlow.Id
	logger.Info("Created AAL2 login flow", "flow_id", flowID)

	// Step 2: Submit the TOTP code to complete 2FA
	updateLoginFlowBody := ory.UpdateLoginFlowBody{
		UpdateLoginFlowWithTotpMethod: &ory.UpdateLoginFlowWithTotpMethod{
			Method:   "totp",
			TotpCode: req.Code,
		},
	}

	successfulLogin, resp, err := kratosClient.client.FrontendAPI.UpdateLoginFlow(ctx).
		Flow(flowID).
		XSessionToken(sessionToken).
		UpdateLoginFlowBody(updateLoginFlowBody).
		Execute()

	if err != nil {
		logger.Warn("TOTP verification failed", "error", err)
		errorMessage := "Invalid TOTP code"
		if resp != nil {
			if respBody, readErr := io.ReadAll(resp.Body); readErr == nil {
				var kratosError map[string]interface{}
				if jsonErr := json.Unmarshal(respBody, &kratosError); jsonErr == nil {
					if ui, ok := kratosError["ui"].(map[string]interface{}); ok {
						if messages, ok := ui["messages"].([]interface{}); ok && len(messages) > 0 {
							if msg, ok := messages[0].(map[string]interface{}); ok {
								if text, ok := msg["text"].(string); ok {
									errorMessage = text
								}
							}
						}
					}
				}
			}
		}
		return c.JSON(http.StatusUnauthorized, map[string]interface{}{
			"status":  "error",
			"message": errorMessage,
			"LOC":     "SHD_02111030061",
		})
	}

	// Success! Session is now AAL2
	session := successfulLogin.Session
	logger.Info("TOTP verification successful, session upgraded to AAL2",
		"session_id", session.Id,
		"aal", session.GetAuthenticatorAssuranceLevel())

	// Update the session token cookie if a new one was issued
	if successfulLogin.SessionToken != nil {
		newSessionToken := *successfulLogin.SessionToken
		expiredTime := time.Now().Add(cookie_timeout_hours * time.Hour)

		cookie := &http.Cookie{
			Name:     "session_token",
			Value:    newSessionToken,
			Path:     "/",
			Expires:  expiredTime,
			HttpOnly: true,
			Secure:   true,
			SameSite: http.SameSiteLaxMode,
		}
		c.SetCookie(cookie)
	}

	// Extract user info for response
	identity := session.Identity
	var email, firstName, lastName string
	isAdmin := false
	isOwner := false

	if identity != nil && identity.Traits != nil {
		traits, ok := identity.Traits.(map[string]interface{})
		if ok {
			if e, ok := traits["email"].(string); ok {
				email = e
			}
			if name, ok := traits["name"].(map[string]interface{}); ok {
				if first, ok := name["first"].(string); ok {
					firstName = first
				}
				if last, ok := name["last"].(string); ok {
					lastName = last
				}
			}
		}

		if identity.MetadataPublic != nil {
			if admin, ok := identity.MetadataPublic["admin"].(bool); ok {
				isAdmin = admin
			}
			if owner, ok := identity.MetadataPublic["is_owner"].(bool); ok {
				isOwner = owner
			}
		}
	}

	// Log successful 2FA
	msg := fmt.Sprintf("TOTP verification success, email:%s, session upgraded to AAL2", email)
	sysdatastores.AddActivityLog(ApiTypes.ActivityLogDef{
		ActivityName: ApiTypes.ActivityName_Auth,
		ActivityType: ApiTypes.ActivityType_UserLoginSuccess,
		AppName:      ApiTypes.AppName_Auth,
		ModuleName:   ApiTypes.ModuleName_EmailAuth,
		ActivityMsg:  &msg,
		CallerLoc:    "SHD_02111030062",
	})

	// Determine redirect URL
	redirectURL := GetRedirectURL(rc, email, isAdmin, false)

	return c.JSON(http.StatusOK, map[string]interface{}{
		"status":       "ok",
		"message":      "Two-factor authentication successful",
		"redirect_url": redirectURL,
		"LOC":          "SHD_02111030063",
		"session": map[string]interface{}{
			"id":               session.Id,
			"active":           session.Active,
			"expires_at":       session.ExpiresAt,
			"authenticated_at": session.AuthenticatedAt,
			"aal":              session.GetAuthenticatorAssuranceLevel(),
			"identity": map[string]interface{}{
				"id": identity.Id,
				"traits": map[string]interface{}{
					"email": email,
					"name": map[string]interface{}{
						"first": firstName,
						"last":  lastName,
					},
				},
				"metadata_public": map[string]interface{}{
					"admin":    isAdmin,
					"is_owner": isOwner,
				},
			},
		},
	})
}

// ============================================================
// Kratos Admin API Helpers for User Management
// ============================================================

// KratosIdentityUpdate specifies which fields to update on a Kratos identity.
// Only non-nil fields are applied (merged into the existing identity).
type KratosIdentityUpdate struct {
	Traits         map[string]interface{} // e.g. {"email": "...", "name": {"first": "...", "last": "..."}}
	MetadataPublic map[string]interface{} // e.g. {"admin": true, "avatar": "file.jpg"}
	State          *string                // "active" or "inactive"
}

// getKratosAdminURL returns the Kratos Admin API base URL from environment.
func getKratosAdminURL() string {
	adminURL := os.Getenv("KRATOS_ADMIN_URL")
	if adminURL == "" {
		adminURL = "http://localhost:4434"
	}
	return adminURL
}

// KratosIdentityToUserInfo converts a raw Kratos identity JSON map to ApiTypes.UserInfo.
func KratosIdentityToUserInfo(identity map[string]interface{}) *ApiTypes.UserInfo {
	userInfo := &ApiTypes.UserInfo{
		AuthType: "kratos",
		Verified: true,
	}

	if id, ok := identity["id"].(string); ok {
		userInfo.UserId = id
	}

	// Extract traits
	if traits, ok := identity["traits"].(map[string]interface{}); ok {
		if email, ok := traits["email"].(string); ok {
			userInfo.Email = email
			userInfo.UserName = email
		}
		if name, ok := traits["name"].(map[string]interface{}); ok {
			if first, ok := name["first"].(string); ok {
				userInfo.FirstName = first
			}
			if last, ok := name["last"].(string); ok {
				userInfo.LastName = last
			}
		}
	}

	// Extract metadata_public
	if mp, ok := identity["metadata_public"].(map[string]interface{}); ok {
		if admin, ok := mp["admin"].(bool); ok {
			userInfo.Admin = admin
		}
		if owner, ok := mp["is_owner"].(bool); ok {
			userInfo.IsOwner = owner
		}
		if avatar, ok := mp["avatar"].(string); ok {
			userInfo.Avatar = avatar
		}
	}

	// Extract state  user_status
	if state, ok := identity["state"].(string); ok {
		userInfo.UserStatus = state
	} else {
		userInfo.UserStatus = "active" // default
	}

	// Extract timestamps
	if createdAt, ok := identity["created_at"].(string); ok {
		if t, err := time.Parse(time.RFC3339, createdAt); err == nil {
			userInfo.Created = t
		}
	}
	if updatedAt, ok := identity["updated_at"].(string); ok {
		if t, err := time.Parse(time.RFC3339, updatedAt); err == nil {
			userInfo.Updated = t
		}
	}

	return userInfo
}

// KratosListAllIdentities lists all Kratos identities via the Admin API
// and returns them as []*ApiTypes.UserInfo.
func KratosListAllIdentities(logger ApiTypes.JimoLogger) ([]*ApiTypes.UserInfo, error) {
	adminURL := getKratosAdminURL()
	ctx := context.Background()
	httpClient := &http.Client{Timeout: 15 * time.Second}

	reqURL := fmt.Sprintf("%s/admin/identities?per_page=1000", adminURL)
	req, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		logger.Error("Failed to create list identities request", "error", err)
		return nil, fmt.Errorf("failed to create request (SHD_KAH_001): %w", err)
	}
	req.Header.Set("Accept", "application/json")

	resp, err := httpClient.Do(req)
	if err != nil {
		logger.Error("Failed to list identities from Kratos", "error", err)
		return nil, fmt.Errorf("failed to list identities (SHD_KAH_002): %w", err)
	}
	defer resp.Body.Close()

	body, _ := io.ReadAll(resp.Body)
	if resp.StatusCode != http.StatusOK {
		logger.Error("Kratos Admin API error listing identities",
			"status", resp.StatusCode, "body", string(body))
		return nil, fmt.Errorf("kratos error listing identities (SHD_KAH_003): status %d", resp.StatusCode)
	}

	var identities []map[string]interface{}
	if err := json.Unmarshal(body, &identities); err != nil {
		logger.Error("Failed to parse identities response", "error", err)
		return nil, fmt.Errorf("failed to parse identities (SHD_KAH_004): %w", err)
	}

	users := make([]*ApiTypes.UserInfo, 0, len(identities))
	for _, identity := range identities {
		users = append(users, KratosIdentityToUserInfo(identity))
	}

	logger.Info("Listed all Kratos identities", "count", len(users))
	return users, nil
}

// KratosGetIdentityByID fetches a single Kratos identity by ID via the Admin API
// and returns it as *ApiTypes.UserInfo.
func KratosGetIdentityByID(logger ApiTypes.JimoLogger, identityID string) (*ApiTypes.UserInfo, error) {
	adminURL := getKratosAdminURL()
	ctx := context.Background()
	httpClient := &http.Client{Timeout: 10 * time.Second}

	reqURL := fmt.Sprintf("%s/admin/identities/%s", adminURL, identityID)
	req, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		logger.Error("Failed to create get identity request", "error", err, "identity_id", identityID)
		return nil, fmt.Errorf("failed to create request (SHD_KAH_010): %w", err)
	}
	req.Header.Set("Accept", "application/json")

	resp, err := httpClient.Do(req)
	if err != nil {
		logger.Error("Failed to get identity from Kratos", "error", err, "identity_id", identityID)
		return nil, fmt.Errorf("failed to get identity (SHD_KAH_011): %w", err)
	}
	defer resp.Body.Close()

	body, _ := io.ReadAll(resp.Body)
	if resp.StatusCode == http.StatusNotFound {
		logger.Warn("Identity not found in Kratos", "identity_id", identityID)
		return nil, fmt.Errorf("identity not found (SHD_KAH_012): %s", identityID)
	}
	if resp.StatusCode != http.StatusOK {
		logger.Error("Kratos Admin API error getting identity",
			"status", resp.StatusCode, "body", string(body), "identity_id", identityID)
		return nil, fmt.Errorf("kratos error getting identity (SHD_KAH_013): status %d", resp.StatusCode)
	}

	var identity map[string]interface{}
	if err := json.Unmarshal(body, &identity); err != nil {
		logger.Error("Failed to parse identity response", "error", err, "identity_id", identityID)
		return nil, fmt.Errorf("failed to parse identity (SHD_KAH_014): %w", err)
	}

	userInfo := KratosIdentityToUserInfo(identity)
	logger.Info("Fetched Kratos identity", "identity_id", identityID, "email", userInfo.Email)
	return userInfo, nil
}

// KratosGetIdentityByEmail fetches a single Kratos identity by email via the Admin API
// and returns it as *ApiTypes.UserInfo.
// Uses credentials_identifier query parameter to search by email.
func KratosGetIdentityByEmail(logger ApiTypes.JimoLogger, email string) (*ApiTypes.UserInfo, error) {
	adminURL := getKratosAdminURL()
	ctx := context.Background()
	httpClient := &http.Client{Timeout: 10 * time.Second}

	reqURL := fmt.Sprintf("%s/admin/identities?credentials_identifier=%s", adminURL, url.QueryEscape(email))
	req, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		logger.Error("Failed to create get identity by email request", "error", err, "email", email)
		return nil, fmt.Errorf("failed to create request (SHD_KAH_015): %w", err)
	}
	req.Header.Set("Accept", "application/json")

	resp, err := httpClient.Do(req)
	if err != nil {
		logger.Error("Failed to get identity by email from Kratos", "error", err, "email", email)
		return nil, fmt.Errorf("failed to get identity by email (SHD_KAH_016): %w", err)
	}
	defer resp.Body.Close()

	body, _ := io.ReadAll(resp.Body)
	if resp.StatusCode != http.StatusOK {
		logger.Error("Kratos Admin API error getting identity by email",
			"status", resp.StatusCode, "body", string(body), "email", email)
		return nil, fmt.Errorf("kratos error getting identity by email (SHD_KAH_017): status %d", resp.StatusCode)
	}

	var identities []map[string]interface{}
	if err := json.Unmarshal(body, &identities); err != nil {
		logger.Error("Failed to parse identities response", "error", err, "email", email)
		return nil, fmt.Errorf("failed to parse identities (SHD_KAH_018): %w", err)
	}

	if len(identities) == 0 {
		logger.Warn("No identity found for email", "email", email)
		return nil, fmt.Errorf("identity not found for email (SHD_KAH_019): %s", email)
	}

	// Return first match (email should be unique)
	userInfo := KratosIdentityToUserInfo(identities[0])
	logger.Info("Fetched Kratos identity by email", "email", email, "identity_id", userInfo.UserId)
	return userInfo, nil
}

// KratosGetUserInfoByAppToken fetches all Kratos identities that have a matching app token
// in their metadata_public field and returns them as []*ApiTypes.UserInfo.
// App tokens are stored in metadata_public as {"token_name": "token_value"} pairs.
// This function matches both the token name AND the token value.
// One token may match multiple users.
func KratosGetUserInfoByAppToken(
	logger ApiTypes.JimoLogger,
	token_name string,
	token string) ([]*ApiTypes.UserInfo, error) {
	adminURL := getKratosAdminURL()
	ctx := context.Background()
	httpClient := &http.Client{Timeout: 15 * time.Second}

	// Step 1: List all identities
	reqURL := fmt.Sprintf("%s/admin/identities?per_page=1000", adminURL)
	req, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		logger.Error("Failed to create list identities request for app token search", "error", err, "token_name", token_name)
		return nil, fmt.Errorf("failed to create request (SHD_KAH_050): %w", err)
	}
	req.Header.Set("Accept", "application/json")

	resp, err := httpClient.Do(req)
	if err != nil {
		logger.Error("Failed to list identities for app token search", "error", err, "token_name", token_name)
		return nil, fmt.Errorf("failed to list identities (SHD_KAH_051): %w", err)
	}
	defer resp.Body.Close()

	body, _ := io.ReadAll(resp.Body)
	if resp.StatusCode != http.StatusOK {
		logger.Error("Kratos Admin API error listing identities for app token",
			"status", resp.StatusCode, "body", string(body), "token_name", token_name)
		return nil, fmt.Errorf("kratos error listing identities (SHD_KAH_052): status %d", resp.StatusCode)
	}

	var identities []map[string]interface{}
	if err := json.Unmarshal(body, &identities); err != nil {
		logger.Error("Failed to parse identities response for app token search", "error", err, "token_name", token_name)
		return nil, fmt.Errorf("failed to parse identities (SHD_KAH_053): %w", err)
	}

	// Step 2: Filter identities that have the matching app token name AND value in metadata_public
	matchedUsers := make([]*ApiTypes.UserInfo, 0)
	for _, identity := range identities {
		if metadataPublic, ok := identity["metadata_public"].(map[string]interface{}); ok {
			// Check if the token_name exists in metadata_public
			if tokenValue, exists := metadataPublic[token_name]; exists && tokenValue != nil {
				// Convert token value to string and check if it matches the provided token
				if tokenStr, ok := tokenValue.(string); ok && tokenStr == token {
					userInfo := KratosIdentityToUserInfo(identity)
					matchedUsers = append(matchedUsers, userInfo)
					logger.Info("Found identity with matching app token",
						"identity_id", userInfo.UserId, "email", userInfo.Email, "token_name", token_name)
				}
			}
		}
	}

	if len(matchedUsers) == 0 {
		logger.Warn("No identities found with matching app token", "token_name", token_name)
		return []*ApiTypes.UserInfo{}, nil // Return empty array instead of error
	}

	logger.Info("Found identities with matching app token", "token_name", token_name, "count", len(matchedUsers))
	return matchedUsers, nil
}

// UpdateAppTokenByEmail updates or deletes an app token for a user identified by email.
// App tokens are stored in metadata_public as {"token_name": "xxx", "token": "xxx"}.
// If token is empty, the app token identified by tokenName is deleted.
// Returns an error if the user is not found or the update fails.
func UpdateAppTokenByEmail(logger ApiTypes.JimoLogger, email string, tokenName string, token string) error {
	// Step 1: Get the identity by email to retrieve the identity ID
	userInfo, err := KratosGetIdentityByEmail(logger, email)
	if err != nil {
		logger.Error("Failed to get identity by email for app token update",
			"error", err, "email", email, "token_name", tokenName)
		return fmt.Errorf("failed to get identity by email (SHD_KAH_040): %w", err)
	}

	// Step 2: Get the raw identity to access metadata_public
	rawIdentity, err := kratosGetRawIdentity(userInfo.UserId)
	if err != nil {
		logger.Error("Failed to get raw identity for app token update",
			"error", err, "identity_id", userInfo.UserId, "token_name", tokenName)
		return fmt.Errorf("failed to get raw identity (SHD_KAH_041): %w", err)
	}

	// Step 3: Extract existing metadata_public
	metadataPublic := make(map[string]interface{})
	if mp, ok := rawIdentity["metadata_public"].(map[string]interface{}); ok {
		// Copy existing metadata_public
		for k, v := range mp {
			metadataPublic[k] = v
		}
	}

	// Step 4: Update or delete the app token
	if token == "" {
		// Delete the app token if token is empty
		delete(metadataPublic, tokenName)
		logger.Info("Deleting app token from metadata_public",
			"email", email, "identity_id", userInfo.UserId, "token_name", tokenName)
	} else {
		// Update or add the app token
		metadataPublic[tokenName] = token
		logger.Info("Updating app token in metadata_public",
			"email", email, "identity_id", userInfo.UserId, "token_name", tokenName)
	}

	// Step 5: Update the identity using KratosUpdateIdentityWrapper
	err = KratosUpdateIdentityWrapper(logger, userInfo.UserId, nil, metadataPublic, nil)
	if err != nil {
		logger.Error("Failed to update identity with app token",
			"error", err, "identity_id", userInfo.UserId, "token_name", tokenName)
		return fmt.Errorf("failed to update identity with app token (SHD_KAH_042): %w", err)
	}

	logger.Info("Successfully updated app token",
		"email", email, "identity_id", userInfo.UserId, "token_name", tokenName, "is_delete", token == "")
	return nil
}

// kratosGetRawIdentity fetches the raw JSON identity from Kratos Admin API.
// Used internally by KratosUpdateIdentity for the GET-then-PUT pattern.
func kratosGetRawIdentity(identityID string) (map[string]interface{}, error) {
	adminURL := getKratosAdminURL()
	ctx := context.Background()
	httpClient := &http.Client{Timeout: 10 * time.Second}

	req, err := http.NewRequestWithContext(ctx, "GET",
		fmt.Sprintf("%s/admin/identities/%s", adminURL, identityID), nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request (SHD_KAH_020): %w", err)
	}
	req.Header.Set("Accept", "application/json")

	resp, err := httpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to get identity (SHD_KAH_021): %w", err)
	}
	defer resp.Body.Close()

	body, _ := io.ReadAll(resp.Body)
	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("kratos error (SHD_KAH_022): status %d, body: %s", resp.StatusCode, string(body))
	}

	var identity map[string]interface{}
	if err := json.Unmarshal(body, &identity); err != nil {
		return nil, fmt.Errorf("failed to parse identity (SHD_KAH_023): %w", err)
	}
	return identity, nil
}

// KratosUpdateIdentity updates a Kratos identity using the GET-then-PUT pattern.
// Only non-nil fields in the update struct are applied; all other fields are preserved.
func KratosUpdateIdentity(logger ApiTypes.JimoLogger, identityID string, update KratosIdentityUpdate) error {
	// Step 1: Fetch current identity
	current, err := kratosGetRawIdentity(identityID)
	if err != nil {
		logger.Error("Failed to fetch identity for update", "error", err, "identity_id", identityID)
		return err
	}

	// Step 2: Build update body, preserving existing fields
	updateBody := map[string]interface{}{
		"schema_id": current["schema_id"],
		"traits":    current["traits"],
	}

	// Preserve state (default)
	if state, ok := current["state"].(string); ok {
		updateBody["state"] = state
	} else {
		updateBody["state"] = "active"
	}

	// Preserve metadata_public
	existingMP := make(map[string]interface{})
	if mp, ok := current["metadata_public"].(map[string]interface{}); ok {
		for k, v := range mp {
			existingMP[k] = v
		}
	}

	// Preserve metadata_admin
	if ma, ok := current["metadata_admin"]; ok && ma != nil {
		updateBody["metadata_admin"] = ma
	}

	// Apply trait updates (merge into existing traits)
	if update.Traits != nil {
		existingTraits := make(map[string]interface{})
		if traits, ok := current["traits"].(map[string]interface{}); ok {
			for k, v := range traits {
				existingTraits[k] = v
			}
		}
		for k, v := range update.Traits {
			existingTraits[k] = v
		}
		updateBody["traits"] = existingTraits
	}

	// Apply metadata_public updates (merge into existing)
	if update.MetadataPublic != nil {
		for k, v := range update.MetadataPublic {
			existingMP[k] = v
		}
	}
	updateBody["metadata_public"] = existingMP

	// Apply state update
	if update.State != nil {
		updateBody["state"] = *update.State
	}

	// Step 3: PUT updated identity
	adminURL := getKratosAdminURL()
	ctx := context.Background()
	httpClient := &http.Client{Timeout: 10 * time.Second}

	updateJSON, err := json.Marshal(updateBody)
	if err != nil {
		logger.Error("Failed to marshal update body", "error", err, "identity_id", identityID)
		return fmt.Errorf("failed to marshal update (SHD_KAH_030): %w", err)
	}

	putReq, err := http.NewRequestWithContext(ctx, "PUT",
		fmt.Sprintf("%s/admin/identities/%s", adminURL, identityID),
		strings.NewReader(string(updateJSON)))
	if err != nil {
		logger.Error("Failed to create update request", "error", err, "identity_id", identityID)
		return fmt.Errorf("failed to create update request (SHD_KAH_031): %w", err)
	}
	putReq.Header.Set("Content-Type", "application/json")
	putReq.Header.Set("Accept", "application/json")

	putResp, err := httpClient.Do(putReq)
	if err != nil {
		logger.Error("Failed to update identity in Kratos", "error", err, "identity_id", identityID)
		return fmt.Errorf("failed to update identity (SHD_KAH_032): %w", err)
	}
	defer putResp.Body.Close()

	putBody, _ := io.ReadAll(putResp.Body)
	if putResp.StatusCode != http.StatusOK {
		logger.Error("Kratos Admin API error updating identity",
			"status", putResp.StatusCode, "body", string(putBody), "identity_id", identityID)
		return fmt.Errorf("kratos error updating identity (SHD_KAH_033): status %d, body: %s",
			putResp.StatusCode, string(putBody))
	}

	logger.Info("Updated Kratos identity", "identity_id", identityID)
	return nil
}

// KratosDeleteIdentitySessions deletes all sessions for a Kratos identity.
// Used when deactivating a user to force immediate logout.
func KratosDeleteIdentitySessions(logger ApiTypes.JimoLogger, identityID string) error {
	adminURL := getKratosAdminURL()
	ctx := context.Background()
	httpClient := &http.Client{Timeout: 10 * time.Second}

	req, err := http.NewRequestWithContext(ctx, "DELETE",
		fmt.Sprintf("%s/admin/identities/%s/sessions", adminURL, identityID), nil)
	if err != nil {
		logger.Error("Failed to create delete sessions request", "error", err, "identity_id", identityID)
		return fmt.Errorf("failed to create request (SHD_KAH_040): %w", err)
	}

	resp, err := httpClient.Do(req)
	if err != nil {
		logger.Error("Failed to delete sessions from Kratos", "error", err, "identity_id", identityID)
		return fmt.Errorf("failed to delete sessions (SHD_KAH_041): %w", err)
	}
	defer resp.Body.Close()

	// 204 No Content or 200 OK are both success responses
	if resp.StatusCode != http.StatusNoContent && resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(resp.Body)
		logger.Error("Kratos Admin API error deleting sessions",
			"status", resp.StatusCode, "body", string(body), "identity_id", identityID)
		return fmt.Errorf("kratos error deleting sessions (SHD_KAH_042): status %d", resp.StatusCode)
	}

	logger.Info("Deleted all sessions for identity", "identity_id", identityID)
	return nil
}

// KratosMarkUserVerified marks a user as verified by setting their identity state to "active".
// This is used for admin override or manual verification.
// With Kratos, email verification is normally handled by Kratos flows automatically.
func KratosMarkUserVerified(logger ApiTypes.JimoLogger, email string) error {
	// Get identity by email to find the identity ID
	userInfo, err := KratosGetIdentityByEmail(logger, email)
	if err != nil {
		logger.Error("Failed to get user by email for verification", "email", email, "error", err)
		return fmt.Errorf("failed to get user for verification (SHD_KAH_050): %w", err)
	}

	// Update identity state to "active"
	activeState := "active"
	err = KratosUpdateIdentity(logger, userInfo.UserId, KratosIdentityUpdate{
		State: &activeState,
	})
	if err != nil {
		logger.Error("Failed to mark user verified in Kratos", "email", email, "identity_id", userInfo.UserId, "error", err)
		return fmt.Errorf("failed to mark user verified (SHD_KAH_051): %w", err)
	}

	logger.Info("Marked user verified in Kratos", "email", email, "identity_id", userInfo.UserId)
	return nil
}

// KratosUpdateIdentityWrapper is a wrapper for KratosUpdateIdentity that matches the function pointer signature
// used in EchoFactory to avoid import cycles.
func KratosUpdateIdentityWrapper(
	logger ApiTypes.JimoLogger,
	identityID string,
	traits map[string]interface{},
	metadataPublic map[string]interface{},
	state *string) error {

	update := KratosIdentityUpdate{}

	if len(traits) > 0 {
		update.Traits = traits
	}
	if len(metadataPublic) > 0 {
		update.MetadataPublic = metadataPublic
	}
	if state != nil {
		update.State = state
	}

	return KratosUpdateIdentity(logger, identityID, update)
}
