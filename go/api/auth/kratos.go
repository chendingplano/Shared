////////////////////////////////////////////////////////////
//
// Description:
// A class to interface with Kratos for authentication
//
// Created: 2026/02/07 by Chen Ding, Generated by Claude Code
////////////////////////////////////////////////////////////

package auth

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"html"
	"io"
	"net/http"
	"net/url"
	"os"
	"strings"
	"time"

	"github.com/chendingplano/shared/go/api/ApiTypes"
	"github.com/chendingplano/shared/go/api/ApiUtils"
	"github.com/chendingplano/shared/go/api/EchoFactory"
	"github.com/chendingplano/shared/go/api/loggerutil"
	"github.com/chendingplano/shared/go/api/sysdatastores"
	"github.com/labstack/echo/v4"
	ory "github.com/ory/client-go"
)

// KratosClient wraps the Ory SDK client for Kratos operations
type KratosClient struct {
	client    *ory.APIClient
	publicURL string
	logger    ApiTypes.JimoLogger
}

// Global Kratos client instance
var kratosClient *KratosClient

// InitKratosClient initializes the global Kratos client.
// Call this during application startup.
func InitKratosClient() {
	kratosPublicURL := os.Getenv("KRATOS_PUBLIC_URL")
	errMsg := ""
	if kratosPublicURL == "" {
		errMsg = "missing KRATOS_PUBLIC_URL env variable. Default to http://localhost:4433"
		kratosPublicURL = "http://localhost:4433"
	}

	config := ory.NewConfiguration()
	logger := loggerutil.CreateDefaultLogger("SHD_0207142900")
	if errMsg != "" {
		logger.Error(errMsg)
	}

	config.Servers = ory.ServerConfigurations{{URL: kratosPublicURL}}
	kratosClient = &KratosClient{
		client:    ory.NewAPIClient(config),
		publicURL: kratosPublicURL,
		logger:    logger,
	}

	EchoFactory.GetUserInfoByUserIDFunc = KratosGetIdentityByID
	EchoFactory.GetUserInfoByEmailFunc = KratosGetIdentityByEmail
	EchoFactory.KratosMarkUserVerifiedFunc = KratosMarkUserVerified
	EchoFactory.KratosUpdatePasswordFunc = KratosUpdatePassword
	EchoFactory.KratosUpdateIdentityFunc = KratosUpdateIdentityWrapper
	EchoFactory.UpdateAppTokenByEmailFunc = UpdateAppTokenByEmail
	EchoFactory.GetUserInfoByAppTokenFunc = KratosGetUserInfoByAppToken
}

// GetKratosClient returns the global Kratos client.
// Returns nil if not initialized.
func GetKratosClient() *KratosClient {
	return kratosClient
}

// KratosLoginRequest represents the login request body
type KratosLoginRequest struct {
	Email    string `json:"email"`
	Password string `json:"password"`
}

// KratosLoginResponse represents the successful login response
type KratosLoginResponse struct {
	Session     *ory.Session `json:"session"`
	RedirectURL string       `json:"redirect_url"`
}

// KratosErrorResponse represents an error response
type KratosErrorResponse struct {
	Status  string `json:"status"`
	Message string `json:"message"`
	LOC     string `json:"loc"`
}

// ValidateSession checks if the request has a valid Kratos session
func (k *KratosClient) ValidateSession(c echo.Context) (*ory.Session, error) {
	cookies := c.Request().Header.Get("Cookie")
	sessionToken := c.Request().Header.Get("X-Session-Token")

	// If no X-Session-Token header, check for our custom session_token cookie
	// (used when session token was stored from native API flow)
	if sessionToken == "" {
		if cookie, err := c.Cookie("session_token"); err == nil && cookie.Value != "" {
			sessionToken = cookie.Value
			k.logger.Info("Using session token from cookie", "token", sessionToken[:min(10, len(sessionToken))]+"...")
		}
	}

	ctx := context.Background()
	req := k.client.FrontendAPI.ToSession(ctx)

	// Pass cookies for browser flow sessions
	if cookies != "" {
		req = req.Cookie(cookies)
	}
	// Pass session token for native/API flow sessions
	if sessionToken != "" {
		req = req.XSessionToken(sessionToken)
	}

	session, resp, err := req.Execute()
	if err != nil {
		if strings.HasPrefix(err.Error(), "401") {
			k.logger.Warn("user not logged in", "error", err)
		} else {
			k.logger.Error("failed validating session", "error", err)
		}

		if resp != nil {
			k.logger.Info("resp", "resp", resp)
		}
		if resp != nil && resp.StatusCode == http.StatusUnauthorized {
			return nil, echo.NewHTTPError(http.StatusUnauthorized,
				fmt.Sprintf("No valid session found, error:%v (SHD_0207142600)", err))
		}
		// Handle 403 Forbidden - this typically means AAL2 is required but session is AAL1
		// The user has 2FA configured but hasn't completed it
		if resp != nil && resp.StatusCode == http.StatusForbidden {
			return nil, echo.NewHTTPError(http.StatusForbidden,
				fmt.Sprintf("Session requires two-factor authentication, error:%v (SHD_0207142602)", err))
		}
		return nil, echo.NewHTTPError(http.StatusInternalServerError,
			fmt.Sprintf("Failed to validate session, error:%v (SHD_0207142601)", err))
	}

	return session, nil
}

// HandleEmailLoginKratos handles email/password login via Ory Kratos.
// This is the Kratos-based replacement for HandleEmailLogin.
//
// Flow:
//  1. Create a native login flow via Kratos API
//  2. Submit email/password credentials to the flow
//  3. On success, return session info and redirect URL
//  4. Kratos sets the session cookie automatically
func HandleEmailLoginKratos(c echo.Context) error {
	rc := EchoFactory.NewFromEcho(c, "SHD_0211103000")
	defer rc.Close()
	logger := rc.GetLogger()

	// SECURITY: Rate limiting to prevent brute-force attacks
	clientIP := c.RealIP()
	allowed, _, retryAfter := CheckLoginRateLimit(clientIP)
	if !allowed {
		logger.Warn("Rate limit exceeded for login",
			"ip", clientIP,
			"retry_after", retryAfter.String())
		return c.JSON(http.StatusTooManyRequests, KratosErrorResponse{
			Status:  "error",
			Message: "Too many login attempts. Please try again later.",
			LOC:     "SHD_0207143400",
		})
	}

	// SECURITY: Validate request origin to prevent CSRF attacks
	if !IsSafeOrigin(c) {
		logger.Warn("CSRF protection: rejected cross-origin request",
			"origin", c.Request().Header.Get("Origin"),
			"referer", c.Request().Header.Get("Referer"))
		return c.JSON(http.StatusForbidden, KratosErrorResponse{
			Status:  "error",
			Message: "Invalid request origin",
			LOC:     "SHD_0207143401",
		})
	}

	body, err := io.ReadAll(c.Request().Body)
	if err != nil {
		logger.Error("Failed to read request body", "error", err)
		return c.JSON(http.StatusBadRequest, KratosErrorResponse{
			Status:  "error",
			Message: "Failed to read request body",
			LOC:     "SHD_0207144100",
		})
	}

	statusCode, response := HandleEmailLoginKratosBase(rc, body, clientIP, c)
	return c.JSON(statusCode, response)
}

// HandleEmailLoginKratosBase processes email login requests via Kratos.
// Returns (status_code, response_map).
func HandleEmailLoginKratosBase(
	rc ApiTypes.RequestContext,
	body []byte,
	clientIP string,
	c echo.Context) (int, map[string]interface{}) {

	logger := rc.GetLogger()
	logger.Info("HandleEmailLoginKratos called")

	if kratosClient == nil {
		InitKratosClient()
	}

	// Parse request
	var req KratosLoginRequest
	if err := json.Unmarshal(body, &req); err != nil {
		errorMsg := "invalid request body (SHD_0211103001)"
		logger.Error("invalid request body", "error", err)

		sysdatastores.AddActivityLog(ApiTypes.ActivityLogDef{
			ActivityName: ApiTypes.ActivityName_Auth,
			ActivityType: ApiTypes.ActivityType_BadRequest,
			AppName:      ApiTypes.AppName_Auth,
			ModuleName:   ApiTypes.ModuleName_EmailAuth,
			ActivityMsg:  &errorMsg,
			CallerLoc:    "SHD_0211103002",
		})

		return http.StatusBadRequest, map[string]interface{}{
			"status":  "error",
			"message": errorMsg,
			"LOC":     "SHD_0207144100",
		}
	}

	if !isValidEmail(req.Email) {
		errorMsg := "invalid email format (SHD_0211103003)"
		logger.Error("invalid email format", "email", req.Email)

		sysdatastores.AddActivityLog(ApiTypes.ActivityLogDef{
			ActivityName: ApiTypes.ActivityName_Auth,
			ActivityType: ApiTypes.ActivityType_BadEmail,
			AppName:      ApiTypes.AppName_Auth,
			ModuleName:   ApiTypes.ModuleName_EmailAuth,
			ActivityMsg:  &errorMsg,
			CallerLoc:    "SHD_0211103004",
		})

		return http.StatusBadRequest, map[string]interface{}{
			"status":  "error",
			"message": errorMsg,
			"LOC":     "SHD_0211103005",
		}
	}

	// SECURITY: Check per-account rate limiting
	accountAllowed, _, accountRetryAfter := CheckAccountLockout(req.Email)
	if !accountAllowed {
		logger.Warn("Account locked due to too many failed attempts",
			"email", req.Email,
			"retry_after", accountRetryAfter.String())

		sysdatastores.AddActivityLog(ApiTypes.ActivityLogDef{
			ActivityName: ApiTypes.ActivityName_Auth,
			ActivityType: ApiTypes.ActivityType_AuthFailure,
			AppName:      ApiTypes.AppName_Auth,
			ModuleName:   ApiTypes.ModuleName_EmailAuth,
			ActivityMsg:  func() *string { s := fmt.Sprintf("Account locked: %s", req.Email); return &s }(),
			CallerLoc:    "SHD_0207144101",
		})

		return http.StatusTooManyRequests, map[string]interface{}{
			"status":  "error",
			"message": "This account is temporarily locked due to too many failed login attempts.",
			"LOC":     "SHD_0207144102",
		}
	}

	ctx := context.Background()

	// Step 1: Create a native login flow
	// Native flows are for API clients (not browser redirects)
	loginFlow, resp, err := kratosClient.client.FrontendAPI.CreateNativeLoginFlow(ctx).Execute()
	if err != nil {
		logger.Error("Failed to create login flow", "error", err)
		if resp != nil {
			logger.Error("Kratos response", "status", resp.StatusCode)
		}

		return http.StatusInternalServerError, map[string]interface{}{
			"status":  "error",
			"message": "Failed to initialize login",
			"LOC":     "SHD_0211103006",
		}
	}

	flowID := loginFlow.Id
	logger.Info("Created login flow", "flow_id", flowID)

	// Step 2: Submit the login credentials to Kratos
	updateLoginFlowBody := ory.UpdateLoginFlowBody{
		UpdateLoginFlowWithPasswordMethod: &ory.UpdateLoginFlowWithPasswordMethod{
			Method:     "password",
			Identifier: req.Email,
			Password:   req.Password,
		},
	}

	successfulLogin, resp, err := kratosClient.client.FrontendAPI.UpdateLoginFlow(ctx).
		Flow(flowID).
		UpdateLoginFlowBody(updateLoginFlowBody).
		Execute()

	if err != nil {
		// Parse Kratos error response for better error messages
		errorMessage := "Invalid email or password"
		if resp != nil {
			if resp.StatusCode == http.StatusBadRequest || resp.StatusCode == http.StatusUnauthorized {
				logger.Warn("Login failed", "email", req.Email, "error", err, "statusCode", resp.StatusCode)
				if respBody, readErr := io.ReadAll(resp.Body); readErr == nil {
					errorMessage = parseKratosUIError(respBody, errorMessage)
				}
			} else {
				logger.Warn("Login failed (unrecog status code)",
					"email", req.Email, "error", err, "statusCode", resp.StatusCode)
				errorMessage = fmt.Sprintf("login failed, unrecog statusCode:%d, email:%s", resp.StatusCode, req.Email)
			}
		} else {
			logger.Error("Login failed (resp is nil)", "email", req.Email, "error", err)
			errorMessage = fmt.Sprintf("login failed (resp is nil), email:%s", req.Email)
		}

		sysdatastores.AddActivityLog(ApiTypes.ActivityLogDef{
			ActivityName: ApiTypes.ActivityName_Auth,
			ActivityType: ApiTypes.ActivityType_AuthFailure,
			AppName:      ApiTypes.AppName_Auth,
			ModuleName:   ApiTypes.ModuleName_EmailAuth,
			ActivityMsg:  func() *string { s := fmt.Sprintf("Login failed: %s", req.Email); return &s }(),
			CallerLoc:    "SHD_0211103007",
		})

		return http.StatusUnauthorized, map[string]interface{}{
			"status":  "error",
			"message": errorMessage,
			"LOC":     "SHD_0207144103",
		}
	}

	// Success! We have a valid session
	session := successfulLogin.Session
	if session.Id == "" {
		logger.Error("Login succeeded but no session returned")
		return http.StatusInternalServerError, map[string]interface{}{
			"status":  "error",
			"message": "Login succeeded but session creation failed",
			"LOC":     "SHD_0207144104",
		}
	}

	// Check if the session is AAL1 and identity has 2FA configured
	// This means user needs to complete 2FA before accessing protected resources
	sessionAAL := session.GetAuthenticatorAssuranceLevel()
	logger.Info("Session AAL after password login",
		"aal", sessionAAL,
		"session_id", session.Id)

	// Extract user info from Kratos identity
	var email, firstName, lastName string
	// Check for admin/owner in metadata
	isAdmin := false
	isOwner := false
	identity := session.Identity

	// If identity is nil, try to fetch it via Admin API using the email
	// This can happen when Kratos doesn't include the full identity in the login response
	if identity == nil {
		logger.Info("Identity nil in login response, fetching via Admin API",
			"session_id", session.Id,
			"email", req.Email)

		adminURL := getKratosAdminURL()

		// Use direct HTTP request to Admin API for better control
		httpClient := &http.Client{Timeout: 10 * time.Second}
		adminReq, _ := http.NewRequestWithContext(ctx, "GET",
			fmt.Sprintf("%s/admin/identities?credentials_identifier=%s", adminURL, url.QueryEscape(req.Email)), nil)
		adminReq.Header.Set("Accept", "application/json")

		adminResp, adminErr := httpClient.Do(adminReq)
		if adminErr != nil {
			logger.Error("Failed to call Admin API", "error", adminErr)
		} else {
			defer adminResp.Body.Close()
			respBody, _ := io.ReadAll(adminResp.Body)

			if adminResp.StatusCode == http.StatusOK {
				var identities []ory.Identity
				if jsonErr := json.Unmarshal(respBody, &identities); jsonErr == nil && len(identities) > 0 {
					identity = &identities[0]
					logger.Info("Successfully fetched identity via Admin API",
						"identity_id", identity.Id)
				} else {
					logger.Error("Failed to parse identities or no identities found",
						"parse_error", jsonErr,
						"response", string(respBody))
				}
			} else {
				logger.Error("Admin API returned error",
					"status_code", adminResp.StatusCode,
					"response", string(respBody))
			}
		}
	}

	// Check if identity has TOTP configured (indicating 2FA is required)
	identityHasTOTP := checkIdentityHasTOTP(ctx, identity, logger)

	// If identity has TOTP and session is AAL1, user needs to complete 2FA
	if identityHasTOTP && sessionAAL == ory.AUTHENTICATORASSURANCELEVEL_AAL1 {
		logger.Info("User has 2FA configured, requiring TOTP verification",
			"email", req.Email,
			"session_id", session.Id)

		// Set the session token cookie so the 2FA verification can use it
		if successfulLogin.SessionToken != nil {
			setSessionTokenCookie(c, *successfulLogin.SessionToken)
		}

		// Return response indicating 2FA is required
		return http.StatusOK, map[string]interface{}{
			"status":       "2fa_required",
			"message":      "Two-factor authentication required",
			"redirect_url": "/verify-2fa",
			"LOC":          "SHD_02111030008",
			"session_id":   session.Id,
		}
	}

	// SECURITY: Reset rate limits on successful login
	if clientIP != "" {
		ResetLoginRateLimits(clientIP, req.Email)
	}

	if identity == nil {
		logger.Error("Login succeeded but session has no identity",
			"session_id", session.Id,
			"email", req.Email)
		return http.StatusInternalServerError, map[string]interface{}{
			"status":  "error",
			"message": "Login succeeded but session has no identity",
			"LOC":     "SHD_02111030009",
		}
	}

	info := extractIdentityInfo(identity)
	email = info.Email
	firstName = info.FirstName
	lastName = info.LastName
	isAdmin = info.IsAdmin
	isOwner = info.IsOwner
	avatar := info.Avatar

	// Set the session token as a cookie for the frontend
	// IMPORTANT: We use "session_token" cookie name (not "ory_kratos_session") because:
	// - "ory_kratos_session" is reserved for browser flow cookies set by Kratos itself
	// - Native/API flow tokens must be passed via X-Session-Token header to Kratos
	// - ValidateSession reads from "session_token" cookie and passes to Kratos via X-Session-Token
	if successfulLogin.SessionToken != nil {
		sessionToken := *successfulLogin.SessionToken
		setSessionTokenCookie(c, sessionToken)

		// Also log the session
		customLayout := "2006-01-02 15:04:05"
		expiredTimeStr := time.Now().Add(cookie_timeout_hours * time.Hour).Format(customLayout)

		sysdatastores.AddSessionLog(sysdatastores.SessionLogDef{
			LoginMethod:  "kratos_login",
			SessionID:    session.Id,
			AuthToken:    ApiUtils.MaskToken(sessionToken),
			Status:       "active",
			UserName:     email,
			UserNameType: "email",
			UserRegID:    identity.Id,
			UserEmail:    &email,
			CallerLoc:    "SHD_0211103010",
			ExpiresAt:    &expiredTimeStr,
		})
	}

	// Log successful login
	logger.Info("Kratos login success",
		"email", email,
		"identity_id", identity.Id,
		"session_id", session.Id,
		"admin", isAdmin,
		"is_owner", isOwner)

	msg := fmt.Sprintf("Kratos login success, email:%s, identity_id:%s",
		email, identity.Id)
	sysdatastores.AddActivityLog(ApiTypes.ActivityLogDef{
		ActivityName: ApiTypes.ActivityName_Auth,
		ActivityType: ApiTypes.ActivityType_UserLoginSuccess,
		AppName:      ApiTypes.AppName_Auth,
		ModuleName:   ApiTypes.ModuleName_EmailAuth,
		ActivityMsg:  &msg,
		CallerLoc:    "SHD_0211103011",
	})

	// Determine redirect URL (use existing GetRedirectURL from auth-util.go)
	// Note: isOwner handling would need to be added to GetRedirectURL if needed
	redirectURL := GetRedirectURL(rc, email, isAdmin, false)

	// Build response matching the expected frontend format
	return http.StatusOK, map[string]interface{}{
		"status":       "ok",
		"redirect_url": redirectURL,
		"LOC":          "SHD_0207144105",
		"session": map[string]interface{}{
			"id":               session.Id,
			"active":           session.Active,
			"expires_at":       session.ExpiresAt,
			"authenticated_at": session.AuthenticatedAt,
			"identity": map[string]interface{}{
				"id": identity.Id,
				"traits": map[string]interface{}{
					"email": email,
					"name": map[string]interface{}{
						"first": firstName,
						"last":  lastName,
					},
				},
				"metadata_public": map[string]interface{}{
					"admin":    isAdmin,
					"is_owner": isOwner,
					"avatar":   avatar,
				},
				"state":      identity.State,
				"created_at": identity.CreatedAt,
				"updated_at": identity.UpdatedAt,
			},
		},
	}
}

// HandleAuthMeKratos returns the current user's session info via Kratos.
// This is the Kratos-based replacement for HandleAuthMe.
func HandleAuthMeKratos(c echo.Context) error {
	rc := EchoFactory.NewFromEcho(c, "SHD_0211103012")
	defer rc.Close()
	logger := rc.GetLogger()

	if kratosClient == nil {
		InitKratosClient()
	}

	// Validate session with Kratos
	session, err := kratosClient.ValidateSession(c)
	if err != nil {
		logger.Warn("user not logged in", "error", err)
		return c.JSON(http.StatusUnauthorized, map[string]interface{}{
			"authenticated": false,
			"message":       "No valid session",
			"LOC":           "SHD_0207143100",
		})
	}

	identity := session.Identity
	info := extractIdentityInfo(identity)

	baseURL := os.Getenv("APP_BASE_URL")

	return c.JSON(http.StatusOK, map[string]interface{}{
		"base_url": baseURL,
		"LOC":      "SHD_0207143201",
		"session": map[string]interface{}{
			"id":               session.Id,
			"active":           session.Active,
			"expires_at":       session.ExpiresAt,
			"authenticated_at": session.AuthenticatedAt,
			"identity": map[string]interface{}{
				"id": identity.Id,
				"traits": map[string]interface{}{
					"email": info.Email,
					"name": map[string]interface{}{
						"first": info.FirstName,
						"last":  info.LastName,
					},
				},
				"metadata_public": map[string]interface{}{
					"admin":    info.IsAdmin,
					"is_owner": info.IsOwner,
					"avatar":   info.Avatar,
				},
				"state":      identity.State,
				"created_at": identity.CreatedAt,
				"updated_at": identity.UpdatedAt,
			},
		},
	})
}

// HandleLogoutKratos handles logout via Kratos.
func HandleLogoutKratos(c echo.Context) error {
	rc := EchoFactory.NewFromEcho(c, "SHD_0211103013")
	defer rc.Close()
	logger := rc.GetLogger()

	if kratosClient == nil {
		InitKratosClient()
	}

	ctx := context.Background()
	cookies := c.Request().Header.Get("Cookie")

	// Create a browser logout flow (works for both browser and API clients)
	logoutFlow, resp, err := kratosClient.client.FrontendAPI.CreateBrowserLogoutFlow(ctx).
		Cookie(cookies).
		Execute()

	if err != nil {
		logger.Warn("Failed to create logout flow", "error", err)
		if resp != nil {
			logger.Warn("Kratos response", "status", resp.StatusCode)
		}
		// Even if Kratos fails, clear local cookies
		clearSessionCookies(c)
		return c.JSON(http.StatusOK, map[string]interface{}{
			"status":       "ok",
			"message":      "Logged out (local)",
			"redirect_url": "/login",
			"LOC":          "SHD_0207143300",
		})
	}

	// Submit the logout flow to actually log out using the logout token
	_, err = kratosClient.client.FrontendAPI.UpdateLogoutFlow(ctx).
		Token(logoutFlow.LogoutToken).
		Execute()

	if err != nil {
		logger.Warn("Failed to perform logout", "error", err)
	}

	// Clear local session cookies
	clearSessionCookies(c)

	logger.Info("Logout success")

	return c.JSON(http.StatusOK, map[string]interface{}{
		"status":       "ok",
		"message":      "Logged out successfully",
		"redirect_url": "/login",
		"LOC":          "SHD_0207143301",
	})
}

// clearSessionCookies clears all session-related cookies
func clearSessionCookies(c echo.Context) {
	cookiesToClear := []string{"session_id", "session_token", "ory_kratos_session"}
	for _, name := range cookiesToClear {
		cookie := &http.Cookie{
			Name:     name,
			Value:    "",
			Path:     "/",
			MaxAge:   -1,
			HttpOnly: true,
			Secure:   true,
		}
		c.SetCookie(cookie)
	}
}

// getMapKeys returns the keys of a map[string]interface{} for logging purposes
func getMapKeys(m map[string]interface{}) []string {
	keys := make([]string, 0, len(m))
	for k := range m {
		keys = append(keys, k)
	}
	return keys
}

// ---------------------------------------------------------------------------
// Helpers: extracted to reduce duplication across handlers
// ---------------------------------------------------------------------------

// identityInfo holds extracted user fields from a Kratos identity.
type identityInfo struct {
	Email     string
	FirstName string
	LastName  string
	IsAdmin   bool
	IsOwner   bool
	Avatar    string
}

// extractIdentityInfo extracts common user fields from a Kratos identity's
// untyped traits and metadata_public maps.
func extractIdentityInfo(identity *ory.Identity) identityInfo {
	var info identityInfo
	if identity == nil {
		return info
	}
	if identity.Traits != nil {
		if traits, ok := identity.Traits.(map[string]interface{}); ok {
			if email, ok := traits["email"].(string); ok {
				info.Email = email
			}
			if name, ok := traits["name"].(map[string]interface{}); ok {
				if first, ok := name["first"].(string); ok {
					info.FirstName = first
				}
				if last, ok := name["last"].(string); ok {
					info.LastName = last
				}
			}
		}
	}
	if identity.MetadataPublic != nil {
		if admin, ok := identity.MetadataPublic["admin"].(bool); ok {
			info.IsAdmin = admin
		}
		if owner, ok := identity.MetadataPublic["is_owner"].(bool); ok {
			info.IsOwner = owner
		}
		if av, ok := identity.MetadataPublic["avatar"].(string); ok {
			info.Avatar = av
		}
	}
	return info
}

// setSessionTokenCookie sets the session_token cookie for native API flow sessions.
func setSessionTokenCookie(c echo.Context, sessionToken string) {
	c.SetCookie(&http.Cookie{
		Name:     "session_token",
		Value:    sessionToken,
		Path:     "/",
		Expires:  time.Now().Add(cookie_timeout_hours * time.Hour),
		HttpOnly: true,
		Secure:   true,
		SameSite: http.SameSiteLaxMode,
	})
}

// parseKratosUIError extracts a human-readable error message from a Kratos
// error response body. Checks ui.messages, ui.nodes[].messages, and
// error.message. Falls back to defaultMsg if none found.
func parseKratosUIError(body []byte, defaultMsg string) string {
	var kratosError map[string]interface{}
	if err := json.Unmarshal(body, &kratosError); err != nil {
		return defaultMsg
	}
	if ui, ok := kratosError["ui"].(map[string]interface{}); ok {
		if messages, ok := ui["messages"].([]interface{}); ok && len(messages) > 0 {
			if msg, ok := messages[0].(map[string]interface{}); ok {
				if text, ok := msg["text"].(string); ok {
					return text
				}
			}
		}
		if nodes, ok := ui["nodes"].([]interface{}); ok {
			for _, node := range nodes {
				if n, ok := node.(map[string]interface{}); ok {
					if msgs, ok := n["messages"].([]interface{}); ok && len(msgs) > 0 {
						if m, ok := msgs[0].(map[string]interface{}); ok {
							if text, ok := m["text"].(string); ok && text != "" {
								return text
							}
						}
					}
				}
			}
		}
	}
	if errObj, ok := kratosError["error"].(map[string]interface{}); ok {
		if message, ok := errObj["message"].(string); ok {
			return message
		}
	}
	return defaultMsg
}

// checkIdentityHasTOTP checks whether a Kratos identity has TOTP credentials
// configured by first checking the identity object, then fetching from Admin API.
func checkIdentityHasTOTP(ctx context.Context, identity *ory.Identity, logger ApiTypes.JimoLogger) bool {
	if identity == nil {
		return false
	}

	// Check if credentials are already present in the identity
	if identity.Credentials != nil {
		creds := *identity.Credentials
		if _, hasTOTP := creds["totp"]; hasTOTP {
			logger.Info("TOTP found in identity credentials")
			return true
		}
	}

	// Fetch identity with credentials from Admin API
	adminURL := getKratosAdminURL()
	httpClient := &http.Client{Timeout: 10 * time.Second}
	credReq, err := http.NewRequestWithContext(ctx, "GET",
		fmt.Sprintf("%s/admin/identities/%s?include_credential=totp", adminURL, identity.Id), nil)
	if err != nil {
		logger.Warn("Failed to create credentials request", "error", err)
		return false
	}
	credReq.Header.Set("Accept", "application/json")

	credResp, credErr := httpClient.Do(credReq)
	if credErr != nil {
		logger.Warn("Failed to fetch identity with credentials", "error", credErr)
		return false
	}
	defer credResp.Body.Close()
	credBody, _ := io.ReadAll(credResp.Body)

	logger.Info("Admin API credentials response",
		"status", credResp.StatusCode,
		"body_length", len(credBody))

	if credResp.StatusCode != http.StatusOK {
		return false
	}

	var rawIdentity map[string]interface{}
	if jsonErr := json.Unmarshal(credBody, &rawIdentity); jsonErr != nil {
		logger.Warn("Failed to parse identity with credentials", "parse_error", jsonErr)
		return false
	}

	if creds, ok := rawIdentity["credentials"].(map[string]interface{}); ok {
		logger.Info("Credentials found in response", "credential_types", getMapKeys(creds))
		if _, hasTOTP := creds["totp"]; hasTOTP {
			logger.Info("TOTP found via Admin API credentials check", "identity_id", identity.Id)
			return true
		}
	} else {
		logger.Info("No credentials field in response or wrong type")
	}

	return false
}

// KratosAuthMiddleware requires a valid Kratos session.
// Use this middleware for protected routes.
func KratosAuthMiddleware(next echo.HandlerFunc) echo.HandlerFunc {
	return func(c echo.Context) error {
		if kratosClient == nil {
			InitKratosClient()
		}

		session, err := kratosClient.ValidateSession(c)
		if err != nil {
			return err
		}

		// Store session in context for handlers to access
		c.Set("kratos_session", session)
		c.Set("kratos_identity", session.Identity)

		// Also extract email for backwards compatibility with existing code
		traits := session.Identity.Traits.(map[string]interface{})
		if email, ok := traits["email"].(string); ok {
			ctx := context.WithValue(c.Request().Context(), ApiTypes.UserContextKey, email)
			c.SetRequest(c.Request().WithContext(ctx))
		}

		return next(c)
	}
}

// KratosSignupRequest represents the signup request body (Kratos format)
type KratosSignupRequest struct {
	Traits   KratosSignupTraits `json:"traits"`
	Password string             `json:"password"`
	// Legacy format fields (for backward compatibility)
	Email     string `json:"email,omitempty"`
	FirstName string `json:"first_name,omitempty"`
	LastName  string `json:"last_name,omitempty"`
}

// KratosSignupTraits represents the Kratos identity traits
type KratosSignupTraits struct {
	Email string            `json:"email"`
	Name  *KratosSignupName `json:"name,omitempty"`
}

// KratosSignupName represents the name trait
type KratosSignupName struct {
	First string `json:"first,omitempty"`
	Last  string `json:"last,omitempty"`
}

// KratosSignupResponse represents the signup response
type KratosSignupResponse struct {
	Status             string                 `json:"status"`
	Message            string                 `json:"message,omitempty"`
	RedirectURL        string                 `json:"redirect_url,omitempty"`
	Session            map[string]interface{} `json:"session,omitempty"`
	VerificationFlowID string                 `json:"verification_flow_id,omitempty"`
	LOC                string                 `json:"loc"`
}

// HandleEmailSignupKratos handles email/password registration via Ory Kratos.
// This is the Kratos-based replacement for HandleEmailSignup.
//
// Flow:
//  1. Create a native registration flow via Kratos API
//  2. Submit email, name traits, and password to the flow
//  3. On success, return session info (if auto-login enabled) or verification message
func HandleEmailSignupKratos(c echo.Context) error {
	rc := EchoFactory.NewFromEcho(c, "SHD_0211103014")
	defer rc.Close()
	logger := rc.GetLogger()

	// SECURITY: Validate request origin to prevent CSRF attacks
	if !IsSafeOrigin(c) {
		logger.Warn("CSRF protection: rejected cross-origin request",
			"origin", c.Request().Header.Get("Origin"),
			"referer", c.Request().Header.Get("Referer"))
		return c.JSON(http.StatusForbidden, KratosSignupResponse{
			Status:  "error",
			Message: "Invalid request origin",
			LOC:     "SHD_0211103015",
		})
	}

	body, err := io.ReadAll(c.Request().Body)
	if err != nil {
		logger.Error("Failed to read request body", "error", err)
		return c.JSON(http.StatusBadRequest, KratosSignupResponse{
			Status:  "error",
			Message: "Failed to read request body",
			LOC:     "SHD_0211103016",
		})
	}

	statusCode, response := HandleEmailSignupKratosBase(rc, body, c)
	return c.JSON(statusCode, response)
}

// HandleEmailSignupKratosBase processes email signup requests via Kratos.
// Returns (status_code, response).
func HandleEmailSignupKratosBase(
	rc ApiTypes.RequestContext,
	body []byte,
	c echo.Context) (int, KratosSignupResponse) {

	logger := rc.GetLogger()
	logger.Info("HandleEmailSignupKratos called")

	if kratosClient == nil {
		InitKratosClient()
	}

	// Parse request - support both Kratos format and legacy format
	var req KratosSignupRequest
	if err := json.Unmarshal(body, &req); err != nil {
		errorMsg := "invalid request body (SHD_0211103017)"
		logger.Error("invalid request body", "error", err)

		sysdatastores.AddActivityLog(ApiTypes.ActivityLogDef{
			ActivityName: ApiTypes.ActivityName_Auth,
			ActivityType: ApiTypes.ActivityType_BadRequest,
			AppName:      ApiTypes.AppName_Auth,
			ModuleName:   ApiTypes.ModuleName_EmailAuth,
			ActivityMsg:  &errorMsg,
			CallerLoc:    "SHD_0211103018",
		})

		return http.StatusBadRequest, KratosSignupResponse{
			Status:  "error",
			Message: errorMsg,
			LOC:     "SHD_0207180102",
		}
	}

	// Handle legacy format - if traits.email is empty but email field is set
	email := req.Traits.Email
	firstName := ""
	lastName := ""
	if req.Traits.Name != nil {
		firstName = req.Traits.Name.First
		lastName = req.Traits.Name.Last
	}

	// Fallback to legacy format fields
	if email == "" && req.Email != "" {
		email = req.Email
	}
	if firstName == "" && req.FirstName != "" {
		firstName = req.FirstName
	}
	if lastName == "" && req.LastName != "" {
		lastName = req.LastName
	}

	// Validate email
	if !isValidEmail(email) {
		errorMsg := "invalid email format"
		logger.Warn("invalid email format", "email", email)

		sysdatastores.AddActivityLog(ApiTypes.ActivityLogDef{
			ActivityName: ApiTypes.ActivityName_Auth,
			ActivityType: ApiTypes.ActivityType_InvalidEmail,
			AppName:      ApiTypes.AppName_Auth,
			ModuleName:   ApiTypes.ModuleName_EmailAuth,
			ActivityMsg:  &errorMsg,
			CallerLoc:    "SHD_0211103019",
		})

		return http.StatusBadRequest, KratosSignupResponse{
			Status:  "error",
			Message: errorMsg,
			LOC:     "SHD_0207180103",
		}
	}

	// Validate password
	if req.Password == "" {
		errorMsg := "password is required"
		logger.Warn("password is required")

		return http.StatusBadRequest, KratosSignupResponse{
			Status:  "error",
			Message: errorMsg,
			LOC:     "SHD_0207180104",
		}
	}

	// SECURITY: Validate password strength (using existing validation)
	passwordResult := ValidatePasswordDefault(req.Password)
	if !passwordResult.Valid {
		errorDetails := "Password requirements not met"
		if len(passwordResult.Errors) > 0 {
			errorDetails = passwordResult.Errors[0]
		}

		logger.Warn("password validation failed",
			"email", email,
			"strength", passwordResult.Strength,
			"error_count", len(passwordResult.Errors))

		sysdatastores.AddActivityLog(ApiTypes.ActivityLogDef{
			ActivityName: ApiTypes.ActivityName_Auth,
			ActivityType: ApiTypes.ActivityType_WeakPassword,
			AppName:      ApiTypes.AppName_Auth,
			ModuleName:   ApiTypes.ModuleName_EmailAuth,
			ActivityMsg:  &errorDetails,
			CallerLoc:    "SHD_0207180105",
		})

		return http.StatusBadRequest, KratosSignupResponse{
			Status:  "error",
			Message: errorDetails,
			LOC:     "SHD_0207180106",
		}
	}

	ctx := context.Background()

	// Step 1: Create a native registration flow
	regFlow, resp, err := kratosClient.client.FrontendAPI.CreateNativeRegistrationFlow(ctx).Execute()
	if err != nil {
		logger.Error("Failed to create registration flow", "error", err)
		if resp != nil {
			logger.Error("Kratos response", "status", resp.StatusCode)
		}

		return http.StatusInternalServerError, KratosSignupResponse{
			Status:  "error",
			Message: "Failed to initialize registration",
			LOC:     "SHD_0207180107",
		}
	}

	flowID := regFlow.Id
	logger.Info("Created registration flow", "flow_id", flowID)

	// Step 2: Build the traits for Kratos
	traits := map[string]interface{}{
		"email": email,
	}
	if firstName != "" || lastName != "" {
		traits["name"] = map[string]interface{}{
			"first": firstName,
			"last":  lastName,
		}
	}

	// Step 3: Submit the registration credentials to Kratos
	updateRegFlowBody := ory.UpdateRegistrationFlowBody{
		UpdateRegistrationFlowWithPasswordMethod: &ory.UpdateRegistrationFlowWithPasswordMethod{
			Method:   "password",
			Password: req.Password,
			Traits:   traits,
		},
	}

	successfulReg, resp, err := kratosClient.client.FrontendAPI.UpdateRegistrationFlow(ctx).
		Flow(flowID).
		UpdateRegistrationFlowBody(updateRegFlowBody).
		Execute()

	if err != nil {
		logger.Error("Registration failed", "email", email, "error", err)

		// Parse Kratos error response for better error messages
		errorMessage := "Registration failed"
		if resp != nil {
			if respBody, readErr := io.ReadAll(resp.Body); readErr == nil {
				errorMessage = parseKratosUIError(respBody, errorMessage)
			}
		}

		sysdatastores.AddActivityLog(ApiTypes.ActivityLogDef{
			ActivityName: ApiTypes.ActivityName_Auth,
			ActivityType: ApiTypes.ActivityType_AuthFailure,
			AppName:      ApiTypes.AppName_Auth,
			ModuleName:   ApiTypes.ModuleName_EmailAuth,
			ActivityMsg:  func() *string { s := fmt.Sprintf("Registration failed: %s, error: %s", email, errorMessage); return &s }(),
			CallerLoc:    "SHD_0207180108",
		})

		// Handle specific error codes
		statusCode := http.StatusBadRequest
		if resp != nil && resp.StatusCode == http.StatusConflict {
			errorMessage = "An account with this email already exists"
			statusCode = http.StatusConflict
		}

		return statusCode, KratosSignupResponse{
			Status:  "error",
			Message: errorMessage,
			LOC:     "SHD_0211103020",
		}
	}

	// Success! Check if we got a session (auto-login enabled) or need verification
	logger.Info("Registration flow completed", "email", email)

	// Check if Kratos returned a session (auto-login after registration)
	if successfulReg.Session != nil {
		session := successfulReg.Session
		identity := session.Identity
		regInfo := extractIdentityInfo(identity)

		// Set the session token as a cookie (using custom cookie name for native flow tokens)
		if successfulReg.SessionToken != nil {
			sessionToken := *successfulReg.SessionToken
			setSessionTokenCookie(c, sessionToken)

			// Log the session
			customLayout := "2006-01-02 15:04:05"
			expiredTimeStr := time.Now().Add(cookie_timeout_hours * time.Hour).Format(customLayout)

			sysdatastores.AddSessionLog(sysdatastores.SessionLogDef{
				LoginMethod:  "kratos_signup",
				SessionID:    session.Id,
				AuthToken:    ApiUtils.MaskToken(sessionToken),
				Status:       "active",
				UserName:     email,
				UserNameType: "email",
				UserRegID:    identity.Id,
				UserEmail:    &email,
				CallerLoc:    "SHD_0207180109",
				ExpiresAt:    &expiredTimeStr,
			})
		}

		msg := fmt.Sprintf("Kratos signup success with session, email:%s, identity_id:%s",
			email, identity.Id)
		sysdatastores.AddActivityLog(ApiTypes.ActivityLogDef{
			ActivityName: ApiTypes.ActivityName_Auth,
			ActivityType: ApiTypes.ActivityType_SignupSuccess,
			AppName:      ApiTypes.AppName_Auth,
			ModuleName:   ApiTypes.ModuleName_EmailAuth,
			ActivityMsg:  &msg,
			CallerLoc:    "SHD_0207180110",
		})

		logger.Info("Kratos signup success with auto-login",
			"email", email,
			"identity_id", identity.Id,
			"session_id", session.Id)

		redirectURL := GetRedirectURL(rc, email, regInfo.IsAdmin, false)

		// Extract verification flow ID from Kratos continue_with
		var verificationFlowID string
		for _, cw := range successfulReg.ContinueWith {
			if cw.ContinueWithVerificationUi != nil {
				verificationFlowID = cw.ContinueWithVerificationUi.Flow.Id
				logger.Info("Verification flow ID extracted", "flow_id", verificationFlowID)
				break
			}
		}

		return http.StatusOK, KratosSignupResponse{
			Status:             "ok",
			Message:            "Registration successful",
			RedirectURL:        redirectURL,
			VerificationFlowID: verificationFlowID,
			LOC:                "SHD_0211103021",
			Session: map[string]interface{}{
				"id":               session.Id,
				"active":           session.Active,
				"expires_at":       session.ExpiresAt,
				"authenticated_at": session.AuthenticatedAt,
				"identity": map[string]interface{}{
					"id": identity.Id,
					"traits": map[string]interface{}{
						"email": email,
						"name": map[string]interface{}{
							"first": regInfo.FirstName,
							"last":  regInfo.LastName,
						},
					},
					"metadata_public": map[string]interface{}{
						"admin":    regInfo.IsAdmin,
						"is_owner": regInfo.IsOwner,
					},
					"created_at": identity.CreatedAt,
					"updated_at": identity.UpdatedAt,
				},
			},
		}
	}

	// No session returned - verification email will be sent by Kratos
	// (based on Kratos configuration for email verification)
	msg := fmt.Sprintf("Kratos signup success (pending verification), email:%s, identity_id:%s",
		email, successfulReg.Identity.Id)
	sysdatastores.AddActivityLog(ApiTypes.ActivityLogDef{
		ActivityName: ApiTypes.ActivityName_Auth,
		ActivityType: ApiTypes.ActivityType_SignupSuccess,
		AppName:      ApiTypes.AppName_Auth,
		ModuleName:   ApiTypes.ModuleName_EmailAuth,
		ActivityMsg:  &msg,
		CallerLoc:    "SHD_0207180100",
	})

	logger.Info("Kratos signup success (verification pending)",
		"email", email,
		"identity_id", successfulReg.Identity.Id)

	return http.StatusOK, KratosSignupResponse{
		Status:  "ok",
		Message: "Registration successful! Please check your email to verify your account.",
		LOC:     "SHD_0207180101",
	}
}

// IsAuthenticatedKratos checks if the request has a valid Kratos session.
// Returns the user info if authenticated, nil otherwise.
func IsAuthenticatedKratos(rc ApiTypes.RequestContext, c echo.Context) (*ApiTypes.UserInfo, error) {
	logger := rc.GetLogger()

	if kratosClient == nil {
		InitKratosClient()
	}

	session, err := kratosClient.ValidateSession(c)
	if err != nil {
		logger.Info("Kratos session validation failed", "error", err)
		return nil, err
	}

	identity := session.Identity
	info := extractIdentityInfo(identity)

	userStatus := "active"
	if identity.State != nil {
		userStatus = string(*identity.State)
	}

	userInfo := &ApiTypes.UserInfo{
		UserId:     identity.Id,
		UserName:   info.Email,
		Email:      info.Email,
		FirstName:  info.FirstName,
		LastName:   info.LastName,
		Admin:      info.IsAdmin,
		IsOwner:    info.IsOwner,
		Avatar:     info.Avatar,
		UserStatus: userStatus,
		Verified:   true, // Kratos sessions imply verified
		AuthType:   "kratos",
	}

	logger.Debug("Kratos session valid",
		"email", info.Email,
		"identity_id", identity.Id,
		"is_admin", info.IsAdmin,
		"is_owner", info.IsOwner)

	return userInfo, nil
}

// IsAuthenticatedKratosFromRC validates a Kratos session using only RequestContext
// (no echo.Context required). This is used by authmiddleware.KratosAuthenticator
// to validate Kratos sessions as a fallback when the old session_id cookie is not found.
func IsAuthenticatedKratosFromRC(rc ApiTypes.RequestContext) (*ApiTypes.UserInfo, error) {
	logger := rc.GetLogger()

	if kratosClient == nil {
		InitKratosClient()
	}

	req := rc.GetRequest()
	if req == nil {
		return nil, fmt.Errorf("no HTTP request available (SHD_0211100100)")
	}

	cookies := req.Header.Get("Cookie")
	sessionToken := req.Header.Get("X-Session-Token")

	// Check for session_token cookie if no X-Session-Token header
	if sessionToken == "" {
		if cookie, err := req.Cookie("session_token"); err == nil && cookie.Value != "" {
			sessionToken = cookie.Value
		}
	}

	ctx := context.Background()
	toSessionReq := kratosClient.client.FrontendAPI.ToSession(ctx)
	if cookies != "" {
		toSessionReq = toSessionReq.Cookie(cookies)
	}
	if sessionToken != "" {
		toSessionReq = toSessionReq.XSessionToken(sessionToken)
	}

	session, _, err := toSessionReq.Execute()
	if err != nil {
		logger.Info("Kratos session validation failed (RC)", "error", err)
		return nil, err
	}

	identity := session.Identity
	info := extractIdentityInfo(identity)

	userStatus := "active"
	if identity.State != nil {
		userStatus = string(*identity.State)
	}

	userInfo := &ApiTypes.UserInfo{
		UserId:     identity.Id,
		UserName:   info.Email,
		Email:      info.Email,
		FirstName:  info.FirstName,
		LastName:   info.LastName,
		Admin:      info.IsAdmin,
		IsOwner:    info.IsOwner,
		Avatar:     info.Avatar,
		UserStatus: userStatus,
		Verified:   true,
		AuthType:   "kratos",
	}

	logger.Debug("Kratos session valid (RC)",
		"email", info.Email,
		"identity_id", identity.Id,
		"is_admin", info.IsAdmin,
		"is_owner", info.IsOwner)

	return userInfo, nil
}

// KratosTOTPRequest represents the TOTP verification request body
type KratosTOTPRequest struct {
	Code string `json:"code"`
}

// HandleGoogleLoginKratos initiates Google OAuth login via Kratos OIDC.
// This serves an HTML page that auto-submits a form to Kratos, ensuring
// the browser receives Kratos's cookies directly and provides a seamless
// redirect to Google without showing the Kratos UI.
//
// Flow:
//  1. Browser requests /auth/google/login
//  2. Go backend fetches a login flow from Kratos (server-side)
//  3. Go backend returns HTML with auto-submitting form
//  4. Browser submits form directly to Kratos with method=oidc, provider=google
//  5. Kratos sets cookies in browser, redirects to Google
//  6. User authenticates with Google
//  7. Google redirects to Kratos callback (browser has cookies)
//  8. Kratos validates, creates session, redirects to return_to
func HandleGoogleLoginKratos(c echo.Context) error {
	rc := EchoFactory.NewFromEcho(c, "SHD_0211103022")
	defer rc.Close()
	logger := rc.GetLogger()

	logger.Info("HandleGoogleLoginKratos called")

	kratosURL := os.Getenv("KRATOS_PUBLIC_URL")
	if kratosURL == "" {
		logger.Error("KRATOS_PUBLIC_URL not set, defaulting to http://localhost:4433")
		kratosURL = "http://localhost:4433"
	}

	// Get the frontend base URL for OAuth callback
	frontendURL := os.Getenv("APP_BASE_URL")
	if frontendURL == "" {
		logger.Error("APP_BASE_URL not set, defaulting to http://localhost:8080")
		frontendURL = "http://localhost:8080"
	}

	// Get the user's intended destination after login (optional)
	// This will be passed to the OAuth callback for final redirect
	userReturnURL := c.QueryParam("returnUrl")

	// Build the OAuth callback URL - this is where Kratos will redirect after successful login
	// The callback page will then redirect to the appropriate dashboard based on user's role
	callbackURL := fmt.Sprintf("%s/oauth/callback", strings.TrimSuffix(frontendURL, "/"))
	if userReturnURL != "" {
		// Validate the user's return URL for security (can be relative or absolute)
		if ApiUtils.IsSafeReturnURL(userReturnURL) || ApiUtils.IsSafeAbsoluteReturnURL(userReturnURL) {
			callbackURL = fmt.Sprintf("%s?returnUrl=%s", callbackURL, url.QueryEscape(userReturnURL))
		} else {
			logger.Warn("Rejected unsafe returnUrl", "returnUrl", userReturnURL)
		}
	}

	// The return_to URL for Kratos is our OAuth callback endpoint
	returnURL := callbackURL

	// Step 1: Create a browser login flow (server-side) to get the flow ID and action URL
	loginFlowURL := fmt.Sprintf("%s/self-service/login/browser?return_to=%s",
		kratosURL, url.QueryEscape(returnURL))

	httpClient := &http.Client{
		Timeout: 10 * time.Second,
		CheckRedirect: func(req *http.Request, via []*http.Request) error {
			return http.ErrUseLastResponse
		},
	}

	req, err := http.NewRequestWithContext(context.Background(), "GET", loginFlowURL, nil)
	if err != nil {
		logger.Error("Failed to create request", "error", err)
		return c.String(http.StatusInternalServerError, "Failed to initialize login")
	}
	req.Header.Set("Accept", "application/json")

	resp, err := httpClient.Do(req)
	if err != nil {
		logger.Error("Failed to create login flow", "error", err)
		return c.String(http.StatusInternalServerError, "Failed to connect to authentication service")
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		logger.Error("Failed to read response", "error", err)
		return c.String(http.StatusInternalServerError, "Failed to read authentication response")
	}

	// Parse the login flow response
	var loginFlow map[string]interface{}
	if err := json.Unmarshal(body, &loginFlow); err != nil {
		logger.Error("Failed to parse login flow", "error", err, "body", string(body))
		return c.String(http.StatusInternalServerError, "Failed to parse authentication response")
	}

	flowID, ok := loginFlow["id"].(string)
	if !ok || flowID == "" {
		logger.Error("No flow ID in response", "response", string(body))
		return c.String(http.StatusInternalServerError, "Invalid authentication response")
	}

	// Get the action URL from the flow's UI
	actionURL := fmt.Sprintf("%s/self-service/login?flow=%s", kratosURL, flowID)
	if ui, ok := loginFlow["ui"].(map[string]interface{}); ok {
		if action, ok := ui["action"].(string); ok && action != "" {
			actionURL = action
		}
	}

	// Get CSRF token from the flow
	csrfToken := ""
	if ui, ok := loginFlow["ui"].(map[string]interface{}); ok {
		if nodes, ok := ui["nodes"].([]interface{}); ok {
			for _, node := range nodes {
				if n, ok := node.(map[string]interface{}); ok {
					if attrs, ok := n["attributes"].(map[string]interface{}); ok {
						if name, ok := attrs["name"].(string); ok && name == "csrf_token" {
							if value, ok := attrs["value"].(string); ok {
								csrfToken = value
								break
							}
						}
					}
				}
			}
		}
	}

	logger.Info("Created login flow for Google OIDC",
		"flow_id", flowID,
		"action_url", actionURL,
		"has_csrf", csrfToken != "")

	// Forward any cookies from Kratos to the browser
	// This is critical - the browser needs the CSRF cookie
	for _, cookie := range resp.Cookies() {
		c.SetCookie(&http.Cookie{
			Name:     cookie.Name,
			Value:    cookie.Value,
			Path:     cookie.Path,
			Domain:   cookie.Domain,
			Expires:  cookie.Expires,
			MaxAge:   cookie.MaxAge,
			Secure:   cookie.Secure,
			HttpOnly: cookie.HttpOnly,
			SameSite: cookie.SameSite,
		})
	}

	// Step 2: Return an HTML page that auto-submits to Kratos
	// This ensures the browser POSTs directly to Kratos and receives cookies
	// SECURITY: Escape values interpolated into HTML to prevent injection
	safeActionURL := html.EscapeString(actionURL)
	safeCsrfToken := html.EscapeString(csrfToken)

	autoSubmitHTML := fmt.Sprintf(`<!DOCTYPE html>
<html>
<head>
    <title>Redirecting to Google...</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f5f5f5;
        }
        .loading {
            text-align: center;
        }
        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #e0e0e0;
            border-top: 4px solid #4285f4;
            border-radius: 50%%;
            animation: spin 1s linear infinite;
            margin: 0 auto 16px;
        }
        @keyframes spin {
            0%% { transform: rotate(0deg); }
            100%% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="loading">
        <div class="spinner"></div>
        <p>Redirecting to Google...</p>
    </div>
    <form id="oidc-form" action="%s" method="POST" style="display:none;">
        <input type="hidden" name="csrf_token" value="%s">
        <input type="hidden" name="method" value="oidc">
        <input type="hidden" name="provider" value="google">
    </form>
    <script>
        document.getElementById('oidc-form').submit();
    </script>
</body>
</html>`, safeActionURL, safeCsrfToken)

	return c.HTML(http.StatusOK, autoSubmitHTML)
}

// HandleTOTPVerifyKratos handles TOTP verification to upgrade session from AAL1 to AAL2.
// This is called after successful password login when user has 2FA configured.
//
// Flow:
//  1. User has already authenticated with password (AAL1 session exists via cookie)
//  2. Create a login flow with aal=aal2 to request second factor
//  3. Submit the TOTP code to complete 2FA
//  4. Session is upgraded to AAL2
func HandleTOTPVerifyKratos(c echo.Context) error {
	rc := EchoFactory.NewFromEcho(c, "SHD_0211103055")
	defer rc.Close()
	logger := rc.GetLogger()

	logger.Info("HandleTOTPVerifyKratos called")

	// SECURITY: Validate request origin to prevent CSRF attacks
	if !IsSafeOrigin(c) {
		logger.Warn("CSRF protection: rejected cross-origin request",
			"origin", c.Request().Header.Get("Origin"),
			"referer", c.Request().Header.Get("Referer"))
		return c.JSON(http.StatusForbidden, map[string]interface{}{
			"status":  "error",
			"message": "Invalid request origin",
			"LOC":     "SHD_02111030056",
		})
	}

	if kratosClient == nil {
		InitKratosClient()
	}

	// Parse the TOTP code from request
	var req KratosTOTPRequest
	if err := c.Bind(&req); err != nil {
		logger.Error("Failed to parse TOTP request", "error", err)
		return c.JSON(http.StatusBadRequest, map[string]interface{}{
			"status":  "error",
			"message": "Invalid request body",
			"LOC":     "SHD_02111030057",
		})
	}

	if req.Code == "" {
		return c.JSON(http.StatusBadRequest, map[string]interface{}{
			"status":  "error",
			"message": "TOTP code is required",
			"LOC":     "SHD_02111030058",
		})
	}

	// Get the session token from cookie (set during AAL1 login)
	sessionToken := ""
	if cookie, err := c.Cookie("session_token"); err == nil && cookie.Value != "" {
		sessionToken = cookie.Value
	}

	if sessionToken == "" {
		logger.Warn("No session token found for 2FA verification")
		return c.JSON(http.StatusUnauthorized, map[string]interface{}{
			"status":  "error",
			"message": "No active session. Please login again.",
			"LOC":     "SHD_02111030059",
		})
	}

	ctx := context.Background()

	// Step 1: Create a login flow with aal=aal2 to request second factor
	// This tells Kratos we want to upgrade the session to AAL2
	loginFlow, resp, err := kratosClient.client.FrontendAPI.CreateNativeLoginFlow(ctx).
		Aal("aal2").
		XSessionToken(sessionToken).
		Execute()

	if err != nil {
		logger.Error("Failed to create AAL2 login flow", "error", err)
		if resp != nil {
			logger.Error("Kratos response", "status", resp.StatusCode)
		}
		return c.JSON(http.StatusInternalServerError, map[string]interface{}{
			"status":  "error",
			"message": "Failed to initialize 2FA verification",
			"LOC":     "SHD_02111030060",
		})
	}

	flowID := loginFlow.Id
	logger.Info("Created AAL2 login flow", "flow_id", flowID)

	// Step 2: Submit the TOTP code to complete 2FA
	updateLoginFlowBody := ory.UpdateLoginFlowBody{
		UpdateLoginFlowWithTotpMethod: &ory.UpdateLoginFlowWithTotpMethod{
			Method:   "totp",
			TotpCode: req.Code,
		},
	}

	successfulLogin, resp, err := kratosClient.client.FrontendAPI.UpdateLoginFlow(ctx).
		Flow(flowID).
		XSessionToken(sessionToken).
		UpdateLoginFlowBody(updateLoginFlowBody).
		Execute()

	if err != nil {
		logger.Warn("TOTP verification failed", "error", err)
		errorMessage := "Invalid TOTP code"
		if resp != nil {
			if respBody, readErr := io.ReadAll(resp.Body); readErr == nil {
				errorMessage = parseKratosUIError(respBody, errorMessage)
			}
		}
		return c.JSON(http.StatusUnauthorized, map[string]interface{}{
			"status":  "error",
			"message": errorMessage,
			"LOC":     "SHD_02111030061",
		})
	}

	// Success! Session is now AAL2
	session := successfulLogin.Session
	logger.Info("TOTP verification successful, session upgraded to AAL2",
		"session_id", session.Id,
		"aal", session.GetAuthenticatorAssuranceLevel())

	// Update the session token cookie if a new one was issued
	if successfulLogin.SessionToken != nil {
		setSessionTokenCookie(c, *successfulLogin.SessionToken)
	}

	// Extract user info for response
	info := extractIdentityInfo(session.Identity)

	// Log successful 2FA
	msg := fmt.Sprintf("TOTP verification success, email:%s, session upgraded to AAL2", info.Email)
	sysdatastores.AddActivityLog(ApiTypes.ActivityLogDef{
		ActivityName: ApiTypes.ActivityName_Auth,
		ActivityType: ApiTypes.ActivityType_UserLoginSuccess,
		AppName:      ApiTypes.AppName_Auth,
		ModuleName:   ApiTypes.ModuleName_EmailAuth,
		ActivityMsg:  &msg,
		CallerLoc:    "SHD_02111030062",
	})

	// Determine redirect URL
	redirectURL := GetRedirectURL(rc, info.Email, info.IsAdmin, false)

	return c.JSON(http.StatusOK, map[string]interface{}{
		"status":       "ok",
		"message":      "Two-factor authentication successful",
		"redirect_url": redirectURL,
		"LOC":          "SHD_02111030063",
		"session": map[string]interface{}{
			"id":               session.Id,
			"active":           session.Active,
			"expires_at":       session.ExpiresAt,
			"authenticated_at": session.AuthenticatedAt,
			"aal":              session.GetAuthenticatorAssuranceLevel(),
			"identity": map[string]interface{}{
				"id": session.Identity.Id,
				"traits": map[string]interface{}{
					"email": info.Email,
					"name": map[string]interface{}{
						"first": info.FirstName,
						"last":  info.LastName,
					},
				},
				"metadata_public": map[string]interface{}{
					"admin":    info.IsAdmin,
					"is_owner": info.IsOwner,
				},
			},
		},
	})
}

// HandleVerificationFlowKratos proxies the GET request to fetch a Kratos
// verification flow's state. The frontend sends the flow ID as a query param;
// this handler fetches the flow from Kratos server-side and returns it.
func HandleVerificationFlowKratos(c echo.Context) error {
	rc := EchoFactory.NewFromEcho(c, "SHD_0214150001")
	defer rc.Close()
	logger := rc.GetLogger()

	flowID := c.QueryParam("id")
	if flowID == "" {
		return c.JSON(http.StatusBadRequest, map[string]string{
			"status":  "error",
			"message": "Missing flow ID",
			"loc":     "SHD_0214150002",
		})
	}

	if kratosClient == nil {
		InitKratosClient()
	}

	// Fetch the verification flow from Kratos Public API
	ctx := context.Background()
	httpClient := &http.Client{Timeout: 10 * time.Second}

	kratosURL := fmt.Sprintf("%s/self-service/verification/flows?id=%s",
		kratosClient.publicURL, url.QueryEscape(flowID))
	req, err := http.NewRequestWithContext(ctx, "GET", kratosURL, nil)
	if err != nil {
		logger.Error("Failed to create Kratos request", "error", err)
		return c.JSON(http.StatusInternalServerError, map[string]string{
			"status":  "error",
			"message": "Internal server error",
			"loc":     "SHD_0214150003",
		})
	}
	req.Header.Set("Accept", "application/json")

	resp, err := httpClient.Do(req)
	if err != nil {
		logger.Error("Failed to fetch verification flow from Kratos", "error", err)
		return c.JSON(http.StatusBadGateway, map[string]string{
			"status":  "error",
			"message": "Could not connect to the authentication service",
			"loc":     "SHD_0214150004",
		})
	}
	defer resp.Body.Close()

	body, _ := io.ReadAll(resp.Body)

	// Pass through the Kratos response status and body
	c.Response().Header().Set("Content-Type", "application/json")
	return c.JSONBlob(resp.StatusCode, body)
}

// HandleVerificationSubmitKratos proxies the POST request to submit a
// verification code to Kratos. The frontend sends the flow ID and code;
// this handler forwards it to Kratos server-side.
func HandleVerificationSubmitKratos(c echo.Context) error {
	rc := EchoFactory.NewFromEcho(c, "SHD_0214150005")
	defer rc.Close()
	logger := rc.GetLogger()

	// SECURITY: Validate request origin to prevent CSRF attacks
	if !IsSafeOrigin(c) {
		logger.Warn("CSRF protection: rejected cross-origin request",
			"origin", c.Request().Header.Get("Origin"),
			"referer", c.Request().Header.Get("Referer"))
		return c.JSON(http.StatusForbidden, map[string]string{
			"status":  "error",
			"message": "Invalid request origin",
			"loc":     "SHD_0214150006",
		})
	}

	var reqBody struct {
		FlowID string `json:"flow_id"`
		Code   string `json:"code"`
	}
	if err := c.Bind(&reqBody); err != nil {
		logger.Error("Invalid request body", "error", err)
		return c.JSON(http.StatusBadRequest, map[string]string{
			"status":  "error",
			"message": "Invalid request body",
			"loc":     "SHD_0214150007",
		})
	}

	if reqBody.FlowID == "" || reqBody.Code == "" {
		return c.JSON(http.StatusBadRequest, map[string]string{
			"status":  "error",
			"message": "Flow ID and code are required",
			"loc":     "SHD_0214150008",
		})
	}

	if kratosClient == nil {
		InitKratosClient()
	}

	// Submit the verification code to Kratos Public API
	ctx := context.Background()
	httpClient := &http.Client{
		Timeout: 10 * time.Second,
		// Don't follow redirects  Kratos returns 303 on success
		CheckRedirect: func(req *http.Request, via []*http.Request) error {
			return http.ErrUseLastResponse
		},
	}

	kratosURL := fmt.Sprintf("%s/self-service/verification?flow=%s",
		kratosClient.publicURL, url.QueryEscape(reqBody.FlowID))

	jsonBody, _ := json.Marshal(map[string]string{
		"code":   reqBody.Code,
		"method": "code",
	})

	req, err := http.NewRequestWithContext(ctx, "POST", kratosURL, bytes.NewReader(jsonBody))
	if err != nil {
		logger.Error("Failed to create Kratos request", "error", err)
		return c.JSON(http.StatusInternalServerError, map[string]string{
			"status":  "error",
			"message": "Internal server error",
			"loc":     "SHD_0214150009",
		})
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept", "application/json")

	resp, err := httpClient.Do(req)
	if err != nil {
		logger.Error("Failed to submit verification to Kratos", "error", err)
		return c.JSON(http.StatusBadGateway, map[string]string{
			"status":  "error",
			"message": "Could not connect to the authentication service",
			"loc":     "SHD_0214150010",
		})
	}
	defer resp.Body.Close()

	// Kratos returns 303 redirect on success
	if resp.StatusCode == http.StatusSeeOther {
		logger.Info("Verification successful (Kratos 303 redirect)")
		return c.JSON(http.StatusOK, map[string]string{
			"status": "verified",
			"state":  "passed_challenge",
		})
	}

	body, _ := io.ReadAll(resp.Body)

	// Check if the response indicates success
	var result map[string]interface{}
	if err := json.Unmarshal(body, &result); err == nil {
		if state, ok := result["state"].(string); ok && state == "passed_challenge" {
			logger.Info("Verification successful")
			return c.JSON(http.StatusOK, map[string]string{
				"status": "verified",
				"state":  "passed_challenge",
			})
		}
	}

	// Pass through the Kratos response (includes error messages)
	c.Response().Header().Set("Content-Type", "application/json")
	return c.JSONBlob(resp.StatusCode, body)
}

// HandleRecoverySubmitKratos proxies recovery requests to Kratos.
// It handles two states:
// - Email submission (no flow_id): creates a recovery flow and submits the email
// - Code submission (with flow_id and code): submits the recovery code
func HandleRecoverySubmitKratos(c echo.Context) error {
	rc := EchoFactory.NewFromEcho(c, "SHD_0214160001")
	defer rc.Close()
	logger := rc.GetLogger()

	// SECURITY: Validate request origin to prevent CSRF attacks
	if !IsSafeOrigin(c) {
		logger.Warn("CSRF protection: rejected cross-origin request",
			"origin", c.Request().Header.Get("Origin"),
			"referer", c.Request().Header.Get("Referer"))
		return c.JSON(http.StatusForbidden, map[string]string{
			"status":  "error",
			"message": "Invalid request origin",
			"loc":     "SHD_0214160002",
		})
	}

	var reqBody struct {
		Email  string `json:"email"`
		FlowID string `json:"flow_id"`
		Code   string `json:"code"`
	}
	if err := c.Bind(&reqBody); err != nil {
		logger.Error("Invalid request body", "error", err)
		return c.JSON(http.StatusBadRequest, map[string]string{
			"status":  "error",
			"message": "Invalid request body",
			"loc":     "SHD_0214160003",
		})
	}

	if kratosClient == nil {
		InitKratosClient()
	}

	ctx := context.Background()

	// Determine which state we're in based on presence of flow_id
	if reqBody.FlowID == "" {
		// ---- Email submission: create recovery flow, then submit email ----
		if reqBody.Email == "" {
			return c.JSON(http.StatusBadRequest, map[string]string{
				"status":  "error",
				"message": "Email is required",
				"loc":     "SHD_0214160004",
			})
		}

		httpClient := &http.Client{Timeout: 10 * time.Second}

		// Step 1: Create a new recovery flow via Kratos API
		createURL := fmt.Sprintf("%s/self-service/recovery/api", kratosClient.publicURL)
		createReq, err := http.NewRequestWithContext(ctx, "GET", createURL, nil)
		if err != nil {
			logger.Error("Failed to create Kratos recovery flow request", "error", err)
			return c.JSON(http.StatusInternalServerError, map[string]string{
				"status":  "error",
				"message": "Internal server error",
				"loc":     "SHD_0214160005",
			})
		}
		createReq.Header.Set("Accept", "application/json")

		createResp, err := httpClient.Do(createReq)
		if err != nil {
			logger.Error("Failed to create recovery flow from Kratos", "error", err)
			return c.JSON(http.StatusBadGateway, map[string]string{
				"status":  "error",
				"message": "Could not connect to the authentication service",
				"loc":     "SHD_0214160006",
			})
		}
		defer createResp.Body.Close()

		createBody, _ := io.ReadAll(createResp.Body)

		var flowResult map[string]interface{}
		if err := json.Unmarshal(createBody, &flowResult); err != nil {
			logger.Error("Failed to parse recovery flow response", "error", err)
			return c.JSON(http.StatusInternalServerError, map[string]string{
				"status":  "error",
				"message": "Internal server error",
				"loc":     "SHD_0214160007",
			})
		}

		flowID, ok := flowResult["id"].(string)
		if !ok || flowID == "" {
			logger.Error("Recovery flow response missing id", "response", string(createBody))
			return c.JSON(http.StatusInternalServerError, map[string]string{
				"status":  "error",
				"message": "Internal server error",
				"loc":     "SHD_0214160008",
			})
		}

		// Step 2: Submit the email to the recovery flow
		submitHTTPClient := &http.Client{
			Timeout: 10 * time.Second,
			CheckRedirect: func(req *http.Request, via []*http.Request) error {
				return http.ErrUseLastResponse
			},
		}

		submitURL := fmt.Sprintf("%s/self-service/recovery?flow=%s",
			kratosClient.publicURL, url.QueryEscape(flowID))

		jsonBody, _ := json.Marshal(map[string]string{
			"email":  reqBody.Email,
			"method": "code",
		})

		submitReq, err := http.NewRequestWithContext(ctx, "POST", submitURL, bytes.NewReader(jsonBody))
		if err != nil {
			logger.Error("Failed to create Kratos recovery submit request", "error", err)
			// Always return success to not reveal if email exists
			return c.JSON(http.StatusOK, map[string]string{
				"status":  "code_sent",
				"flow_id": flowID,
			})
		}
		submitReq.Header.Set("Content-Type", "application/json")
		submitReq.Header.Set("Accept", "application/json")

		submitResp, err := submitHTTPClient.Do(submitReq)
		if err != nil {
			logger.Error("Failed to submit recovery email to Kratos", "error", err)
			// Always return success to not reveal if email exists
			return c.JSON(http.StatusOK, map[string]string{
				"status":  "code_sent",
				"flow_id": flowID,
			})
		}
		defer submitResp.Body.Close()
		io.ReadAll(submitResp.Body)

		// Always return success regardless of whether email exists
		return c.JSON(http.StatusOK, map[string]string{
			"status":  "code_sent",
			"flow_id": flowID,
		})

	} else {
		// ---- Code submission: submit recovery code to existing flow ----
		if reqBody.Code == "" {
			return c.JSON(http.StatusBadRequest, map[string]string{
				"status":  "error",
				"message": "Code is required",
				"loc":     "SHD_0214160009",
			})
		}

		httpClient := &http.Client{
			Timeout: 10 * time.Second,
			CheckRedirect: func(req *http.Request, via []*http.Request) error {
				return http.ErrUseLastResponse
			},
		}

		submitURL := fmt.Sprintf("%s/self-service/recovery?flow=%s",
			kratosClient.publicURL, url.QueryEscape(reqBody.FlowID))

		jsonBody, _ := json.Marshal(map[string]string{
			"code":   reqBody.Code,
			"method": "code",
		})

		req, err := http.NewRequestWithContext(ctx, "POST", submitURL, bytes.NewReader(jsonBody))
		if err != nil {
			logger.Error("Failed to create Kratos recovery code request", "error", err)
			return c.JSON(http.StatusInternalServerError, map[string]string{
				"status":  "error",
				"message": "Internal server error",
				"loc":     "SHD_0214160010",
			})
		}
		req.Header.Set("Content-Type", "application/json")
		req.Header.Set("Accept", "application/json")

		resp, err := httpClient.Do(req)
		if err != nil {
			logger.Error("Failed to submit recovery code to Kratos", "error", err)
			return c.JSON(http.StatusBadGateway, map[string]string{
				"status":  "error",
				"message": "Could not connect to the authentication service",
				"loc":     "SHD_0214160011",
			})
		}
		defer resp.Body.Close()

		body, _ := io.ReadAll(resp.Body)

		var result map[string]interface{}
		if err := json.Unmarshal(body, &result); err != nil {
			logger.Error("Failed to parse recovery code response", "error", err)
			return c.JSON(http.StatusInternalServerError, map[string]string{
				"status":  "error",
				"message": "Internal server error",
				"loc":     "SHD_0214160012",
			})
		}

		// Kratos returns 422 "browser_location_change_required" when recovery code
		// is VALID  even for API flows. This is the success case.
		if resp.StatusCode == http.StatusUnprocessableEntity {
			if errObj, ok := result["error"].(map[string]interface{}); ok {
				if errID, ok := errObj["id"].(string); ok && errID == "browser_location_change_required" {
					logger.Info("Recovery code verified successfully", "flow_id", reqBody.FlowID)

					// Store recovery flow_id and email in short-lived cookies.
					// These allow the set-password page to identify the user.
					expiry := time.Now().Add(15 * time.Minute)
					c.SetCookie(&http.Cookie{
						Name:     "recovery_flow",
						Value:    reqBody.FlowID,
						Path:     "/",
						Expires:  expiry,
						HttpOnly: true,
						Secure:   true,
						SameSite: http.SameSiteLaxMode,
					})
					c.SetCookie(&http.Cookie{
						Name:     "recovery_email",
						Value:    reqBody.Email,
						Path:     "/",
						Expires:  expiry,
						HttpOnly: true,
						Secure:   true,
						SameSite: http.SameSiteLaxMode,
					})

					return c.JSON(http.StatusOK, map[string]string{
						"status": "success",
					})
				}
			}
		}

		// Check for error messages in Kratos UI messages (invalid code, expired, etc.)
		if ui, ok := result["ui"].(map[string]interface{}); ok {
			if messages, ok := ui["messages"].([]interface{}); ok && len(messages) > 0 {
				if msg, ok := messages[0].(map[string]interface{}); ok {
					if text, ok := msg["text"].(string); ok {
						logger.Warn("Recovery code error from Kratos", "message", text)
						return c.JSON(http.StatusBadRequest, map[string]string{
							"status":  "error",
							"message": text,
							"loc":     "SHD_0214160013",
						})
					}
				}
			}
		}

		// Pass through unexpected Kratos responses
		logger.Warn("Recovery code submission returned unexpected response",
			"status", resp.StatusCode, "body", string(body))
		c.Response().Header().Set("Content-Type", "application/json")
		return c.JSONBlob(resp.StatusCode, body)
	}
}

// HandleSettingsFlowKratos verifies the user has a valid recovery session.
// Called by the set-password page on load to confirm the user can set a new password.
func HandleSettingsFlowKratos(c echo.Context) error {
	rc := EchoFactory.NewFromEcho(c, "SHD_0214160015")
	defer rc.Close()
	logger := rc.GetLogger()

	// Read recovery cookies set after successful code verification
	flowCookie, err := c.Cookie("recovery_flow")
	if err != nil || flowCookie.Value == "" {
		logger.Warn("No recovery_flow cookie found")
		return c.JSON(http.StatusUnauthorized, map[string]string{
			"status":  "error",
			"message": "No recovery session. Please start the recovery process again.",
			"loc":     "SHD_0214160016",
		})
	}

	emailCookie, err := c.Cookie("recovery_email")
	if err != nil || emailCookie.Value == "" {
		logger.Warn("No recovery_email cookie found")
		return c.JSON(http.StatusUnauthorized, map[string]string{
			"status":  "error",
			"message": "No recovery session. Please start the recovery process again.",
			"loc":     "SHD_0214160016b",
		})
	}

	// Verify the recovery flow is in "passed_challenge" state via Kratos public API
	if kratosClient == nil {
		InitKratosClient()
	}

	ctx := context.Background()
	httpClient := &http.Client{Timeout: 10 * time.Second}

	kratosURL := fmt.Sprintf("%s/self-service/recovery/flows?id=%s",
		kratosClient.publicURL, url.QueryEscape(flowCookie.Value))
	req, err := http.NewRequestWithContext(ctx, "GET", kratosURL, nil)
	if err != nil {
		logger.Error("Failed to create Kratos flow check request", "error", err)
		return c.JSON(http.StatusInternalServerError, map[string]string{
			"status":  "error",
			"message": "Internal server error",
			"loc":     "SHD_0214160017",
		})
	}
	req.Header.Set("Accept", "application/json")

	resp, err := httpClient.Do(req)
	if err != nil {
		logger.Error("Failed to check recovery flow", "error", err)
		return c.JSON(http.StatusBadGateway, map[string]string{
			"status":  "error",
			"message": "Could not connect to the authentication service",
			"loc":     "SHD_0214160018",
		})
	}
	defer resp.Body.Close()

	body, _ := io.ReadAll(resp.Body)
	var flowResult map[string]interface{}
	if err := json.Unmarshal(body, &flowResult); err != nil {
		logger.Error("Failed to parse recovery flow response", "error", err)
		return c.JSON(http.StatusInternalServerError, map[string]string{
			"status":  "error",
			"message": "Internal server error",
			"loc":     "SHD_0214160017b",
		})
	}

	state, _ := flowResult["state"].(string)
	if state != "passed_challenge" {
		logger.Warn("Recovery flow not in passed_challenge state", "state", state)
		return c.JSON(http.StatusUnauthorized, map[string]string{
			"status":  "error",
			"message": "Recovery session expired or invalid. Please start over.",
			"loc":     "SHD_0214160017c",
		})
	}

	logger.Info("Recovery session verified", "flow_id", flowCookie.Value)
	return c.JSON(http.StatusOK, map[string]string{
		"status": "ok",
	})
}

// HandleSettingsSubmitKratos sets a new password after recovery code verification.
// It reads the recovery cookies, verifies the flow state, looks up the identity
// by email, and updates the password via the Kratos Admin API.
func HandleSettingsSubmitKratos(c echo.Context) error {
	rc := EchoFactory.NewFromEcho(c, "SHD_0214160019")
	defer rc.Close()
	logger := rc.GetLogger()

	// SECURITY: Validate request origin to prevent CSRF attacks
	if !IsSafeOrigin(c) {
		logger.Warn("CSRF protection: rejected cross-origin request",
			"origin", c.Request().Header.Get("Origin"),
			"referer", c.Request().Header.Get("Referer"))
		return c.JSON(http.StatusForbidden, map[string]string{
			"status":  "error",
			"message": "Invalid request origin",
			"loc":     "SHD_0214160020",
		})
	}

	// Read recovery cookies
	flowCookie, err := c.Cookie("recovery_flow")
	if err != nil || flowCookie.Value == "" {
		logger.Warn("No recovery_flow cookie found for password update")
		return c.JSON(http.StatusUnauthorized, map[string]string{
			"status":  "error",
			"message": "No recovery session. Please start the recovery process again.",
			"loc":     "SHD_0214160021",
		})
	}

	emailCookie, err := c.Cookie("recovery_email")
	if err != nil || emailCookie.Value == "" {
		logger.Warn("No recovery_email cookie found for password update")
		return c.JSON(http.StatusUnauthorized, map[string]string{
			"status":  "error",
			"message": "No recovery session. Please start the recovery process again.",
			"loc":     "SHD_0214160021b",
		})
	}

	var reqBody struct {
		Password string `json:"password"`
	}
	if err := c.Bind(&reqBody); err != nil {
		logger.Error("Invalid request body", "error", err)
		return c.JSON(http.StatusBadRequest, map[string]string{
			"status":  "error",
			"message": "Invalid request body",
			"loc":     "SHD_0214160022",
		})
	}

	if reqBody.Password == "" {
		return c.JSON(http.StatusBadRequest, map[string]string{
			"status":  "error",
			"message": "Password is required",
			"loc":     "SHD_0214160023",
		})
	}

	// Verify the recovery flow is in "passed_challenge" state
	if kratosClient == nil {
		InitKratosClient()
	}

	ctx := context.Background()
	httpClient := &http.Client{Timeout: 10 * time.Second}

	kratosURL := fmt.Sprintf("%s/self-service/recovery/flows?id=%s",
		kratosClient.publicURL, url.QueryEscape(flowCookie.Value))
	flowReq, err := http.NewRequestWithContext(ctx, "GET", kratosURL, nil)
	if err != nil {
		logger.Error("Failed to create flow check request", "error", err)
		return c.JSON(http.StatusInternalServerError, map[string]string{
			"status":  "error",
			"message": "Internal server error",
			"loc":     "SHD_0214160024",
		})
	}
	flowReq.Header.Set("Accept", "application/json")

	flowResp, err := httpClient.Do(flowReq)
	if err != nil {
		logger.Error("Failed to verify recovery flow", "error", err)
		return c.JSON(http.StatusBadGateway, map[string]string{
			"status":  "error",
			"message": "Could not connect to the authentication service",
			"loc":     "SHD_0214160025",
		})
	}
	defer flowResp.Body.Close()

	flowBody, _ := io.ReadAll(flowResp.Body)
	var flowResult map[string]interface{}
	if err := json.Unmarshal(flowBody, &flowResult); err != nil {
		logger.Error("Failed to parse flow response", "error", err)
		return c.JSON(http.StatusInternalServerError, map[string]string{
			"status":  "error",
			"message": "Internal server error",
			"loc":     "SHD_0214160024b",
		})
	}

	state, _ := flowResult["state"].(string)
	if state != "passed_challenge" {
		logger.Warn("Recovery flow not in passed_challenge state for password update", "state", state)
		return c.JSON(http.StatusUnauthorized, map[string]string{
			"status":  "error",
			"message": "Recovery session expired or invalid. Please start over.",
			"loc":     "SHD_0214160024c",
		})
	}

	// Look up identity by email via Kratos Admin API
	userInfo, err := KratosGetIdentityByEmail(logger, emailCookie.Value)
	if err != nil || userInfo == nil {
		logger.Error("Failed to find identity for recovery", "email", emailCookie.Value, "error", err)
		return c.JSON(http.StatusInternalServerError, map[string]string{
			"status":  "error",
			"message": "Could not find account. Please try again.",
			"loc":     "SHD_0214160026",
		})
	}

	// Update password via Kratos Admin API
	adminURL := getKratosAdminURL()
	updateURL := fmt.Sprintf("%s/admin/identities/%s", adminURL, url.PathEscape(userInfo.UserId))

	// First GET the current identity to preserve traits
	getReq, err := http.NewRequestWithContext(ctx, "GET", updateURL, nil)
	if err != nil {
		logger.Error("Failed to create identity GET request", "error", err)
		return c.JSON(http.StatusInternalServerError, map[string]string{
			"status":  "error",
			"message": "Internal server error",
			"loc":     "SHD_0214160027",
		})
	}
	getReq.Header.Set("Accept", "application/json")

	getResp, err := httpClient.Do(getReq)
	if err != nil {
		logger.Error("Failed to get identity from Kratos", "error", err)
		return c.JSON(http.StatusBadGateway, map[string]string{
			"status":  "error",
			"message": "Could not connect to the authentication service",
			"loc":     "SHD_0214160028",
		})
	}
	defer getResp.Body.Close()

	identityBody, _ := io.ReadAll(getResp.Body)
	var identity map[string]interface{}
	if err := json.Unmarshal(identityBody, &identity); err != nil {
		logger.Error("Failed to parse identity response", "error", err)
		return c.JSON(http.StatusInternalServerError, map[string]string{
			"status":  "error",
			"message": "Internal server error",
			"loc":     "SHD_0214160029",
		})
	}

	// Build the update payload: preserve traits and schema, set new password
	updatePayload := map[string]interface{}{
		"schema_id": identity["schema_id"],
		"traits":    identity["traits"],
		"state":     identity["state"],
		"credentials": map[string]interface{}{
			"password": map[string]interface{}{
				"config": map[string]interface{}{
					"password": reqBody.Password,
				},
			},
		},
	}

	updateJSON, _ := json.Marshal(updatePayload)
	putReq, err := http.NewRequestWithContext(ctx, "PUT", updateURL, bytes.NewReader(updateJSON))
	if err != nil {
		logger.Error("Failed to create identity update request", "error", err)
		return c.JSON(http.StatusInternalServerError, map[string]string{
			"status":  "error",
			"message": "Internal server error",
			"loc":     "SHD_0214160030",
		})
	}
	putReq.Header.Set("Content-Type", "application/json")
	putReq.Header.Set("Accept", "application/json")

	putResp, err := httpClient.Do(putReq)
	if err != nil {
		logger.Error("Failed to update identity password", "error", err)
		return c.JSON(http.StatusBadGateway, map[string]string{
			"status":  "error",
			"message": "Could not connect to the authentication service",
			"loc":     "SHD_0214160031",
		})
	}
	defer putResp.Body.Close()

	putBody, _ := io.ReadAll(putResp.Body)

	if putResp.StatusCode != http.StatusOK {
		logger.Error("Kratos Admin API password update failed",
			"status", putResp.StatusCode, "body", string(putBody))
		return c.JSON(http.StatusInternalServerError, map[string]string{
			"status":  "error",
			"message": "Failed to update password. Please try again.",
			"loc":     "SHD_0214160032",
		})
	}

	logger.Info("Password updated successfully via Admin API", "identity_id", userInfo.UserId)

	// Clear recovery cookies
	for _, name := range []string{"recovery_flow", "recovery_email"} {
		c.SetCookie(&http.Cookie{
			Name:     name,
			Value:    "",
			Path:     "/",
			Expires:  time.Unix(0, 0),
			MaxAge:   -1,
			HttpOnly: true,
			Secure:   true,
			SameSite: http.SameSiteLaxMode,
		})
	}

	return c.JSON(http.StatusOK, map[string]string{
		"status": "success",
	})
}

// ============================================================
// Kratos Admin API Helpers for User Management
// ============================================================

// KratosIdentityUpdate specifies which fields to update on a Kratos identity.
// Only non-nil fields are applied (merged into the existing identity).
type KratosIdentityUpdate struct {
	Traits         map[string]interface{} // e.g. {"email": "...", "name": {"first": "...", "last": "..."}}
	MetadataPublic map[string]interface{} // e.g. {"admin": true, "avatar": "file.jpg"}
	State          *string                // "active" or "inactive"
}

// getKratosAdminURL returns the Kratos Admin API base URL from environment.
func getKratosAdminURL() string {
	adminURL := os.Getenv("KRATOS_ADMIN_URL")
	if adminURL == "" {
		adminURL = "http://localhost:4434"
	}
	return adminURL
}

// KratosIdentityToUserInfo converts a raw Kratos identity JSON map to ApiTypes.UserInfo.
func KratosIdentityToUserInfo(identity map[string]interface{}) *ApiTypes.UserInfo {
	userInfo := &ApiTypes.UserInfo{
		AuthType: "kratos",
		Verified: true,
	}

	if id, ok := identity["id"].(string); ok {
		userInfo.UserId = id
	}

	// Extract traits
	if traits, ok := identity["traits"].(map[string]interface{}); ok {
		if email, ok := traits["email"].(string); ok {
			userInfo.Email = email
			userInfo.UserName = email
		}
		if name, ok := traits["name"].(map[string]interface{}); ok {
			if first, ok := name["first"].(string); ok {
				userInfo.FirstName = first
			}
			if last, ok := name["last"].(string); ok {
				userInfo.LastName = last
			}
		}
	}

	// Extract metadata_public
	if mp, ok := identity["metadata_public"].(map[string]interface{}); ok {
		if admin, ok := mp["admin"].(bool); ok {
			userInfo.Admin = admin
		}
		if owner, ok := mp["is_owner"].(bool); ok {
			userInfo.IsOwner = owner
		}
		if avatar, ok := mp["avatar"].(string); ok {
			userInfo.Avatar = avatar
		}
	}

	// Extract state  user_status
	if state, ok := identity["state"].(string); ok {
		userInfo.UserStatus = state
	} else {
		userInfo.UserStatus = "active" // default
	}

	// Extract timestamps
	if createdAt, ok := identity["created_at"].(string); ok {
		if t, err := time.Parse(time.RFC3339, createdAt); err == nil {
			userInfo.Created = t
		}
	}
	if updatedAt, ok := identity["updated_at"].(string); ok {
		if t, err := time.Parse(time.RFC3339, updatedAt); err == nil {
			userInfo.Updated = t
		}
	}

	return userInfo
}

// KratosListAllIdentities lists all Kratos identities via the Admin API
// and returns them as []*ApiTypes.UserInfo.
func KratosListAllIdentities(logger ApiTypes.JimoLogger) ([]*ApiTypes.UserInfo, error) {
	adminURL := getKratosAdminURL()
	ctx := context.Background()
	httpClient := &http.Client{Timeout: 15 * time.Second}

	reqURL := fmt.Sprintf("%s/admin/identities?per_page=1000", adminURL)
	req, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		logger.Error("Failed to create list identities request", "error", err)
		return nil, fmt.Errorf("failed to create request (SHD_KAH_001): %w", err)
	}
	req.Header.Set("Accept", "application/json")

	resp, err := httpClient.Do(req)
	if err != nil {
		logger.Error("Failed to list identities from Kratos", "error", err)
		return nil, fmt.Errorf("failed to list identities (SHD_KAH_002): %w", err)
	}
	defer resp.Body.Close()

	body, _ := io.ReadAll(resp.Body)
	if resp.StatusCode != http.StatusOK {
		logger.Error("Kratos Admin API error listing identities",
			"status", resp.StatusCode, "body", string(body))
		return nil, fmt.Errorf("kratos error listing identities (SHD_KAH_003): status %d", resp.StatusCode)
	}

	var identities []map[string]interface{}
	if err := json.Unmarshal(body, &identities); err != nil {
		logger.Error("Failed to parse identities response", "error", err)
		return nil, fmt.Errorf("failed to parse identities (SHD_KAH_004): %w", err)
	}

	users := make([]*ApiTypes.UserInfo, 0, len(identities))
	for _, identity := range identities {
		users = append(users, KratosIdentityToUserInfo(identity))
	}

	logger.Info("Listed all Kratos identities", "count", len(users))
	return users, nil
}

// KratosGetIdentityByID fetches a single Kratos identity by ID via the Admin API
// and returns it as *ApiTypes.UserInfo.
func KratosGetIdentityByID(logger ApiTypes.JimoLogger, identityID string) (*ApiTypes.UserInfo, error) {
	adminURL := getKratosAdminURL()
	ctx := context.Background()
	httpClient := &http.Client{Timeout: 10 * time.Second}

	reqURL := fmt.Sprintf("%s/admin/identities/%s", adminURL, identityID)
	req, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		logger.Error("Failed to create get identity request", "error", err, "identity_id", identityID)
		return nil, fmt.Errorf("failed to create request (SHD_KAH_010): %w", err)
	}
	req.Header.Set("Accept", "application/json")

	resp, err := httpClient.Do(req)
	if err != nil {
		logger.Error("Failed to get identity from Kratos", "error", err, "identity_id", identityID)
		return nil, fmt.Errorf("failed to get identity (SHD_KAH_011): %w", err)
	}
	defer resp.Body.Close()

	body, _ := io.ReadAll(resp.Body)
	if resp.StatusCode == http.StatusNotFound {
		logger.Warn("Identity not found in Kratos", "identity_id", identityID)
		return nil, fmt.Errorf("identity not found (SHD_KAH_012): %s", identityID)
	}
	if resp.StatusCode != http.StatusOK {
		logger.Error("Kratos Admin API error getting identity",
			"status", resp.StatusCode, "body", string(body), "identity_id", identityID)
		return nil, fmt.Errorf("kratos error getting identity (SHD_KAH_013): status %d", resp.StatusCode)
	}

	var identity map[string]interface{}
	if err := json.Unmarshal(body, &identity); err != nil {
		logger.Error("Failed to parse identity response", "error", err, "identity_id", identityID)
		return nil, fmt.Errorf("failed to parse identity (SHD_KAH_014): %w", err)
	}

	userInfo := KratosIdentityToUserInfo(identity)
	logger.Info("Fetched Kratos identity", "identity_id", identityID, "email", userInfo.Email)
	return userInfo, nil
}

// KratosGetIdentityByEmail fetches a single Kratos identity by email via the Admin API
// and returns it as *ApiTypes.UserInfo.
// Uses credentials_identifier query parameter to search by email.
func KratosGetIdentityByEmail(logger ApiTypes.JimoLogger, email string) (*ApiTypes.UserInfo, error) {
	adminURL := getKratosAdminURL()
	ctx := context.Background()
	httpClient := &http.Client{Timeout: 10 * time.Second}

	reqURL := fmt.Sprintf("%s/admin/identities?credentials_identifier=%s", adminURL, url.QueryEscape(email))
	req, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		logger.Error("Failed to create get identity by email request", "error", err, "email", email)
		return nil, fmt.Errorf("failed to create request (SHD_KAH_015): %w", err)
	}
	req.Header.Set("Accept", "application/json")

	resp, err := httpClient.Do(req)
	if err != nil {
		logger.Error("Failed to get identity by email from Kratos", "error", err, "email", email)
		return nil, fmt.Errorf("failed to get identity by email (SHD_KAH_016): %w", err)
	}
	defer resp.Body.Close()

	body, _ := io.ReadAll(resp.Body)
	if resp.StatusCode != http.StatusOK {
		logger.Error("Kratos Admin API error getting identity by email",
			"status", resp.StatusCode, "body", string(body), "email", email)
		return nil, fmt.Errorf("kratos error getting identity by email (SHD_KAH_017): status %d", resp.StatusCode)
	}

	var identities []map[string]interface{}
	if err := json.Unmarshal(body, &identities); err != nil {
		logger.Error("Failed to parse identities response", "error", err, "email", email)
		return nil, fmt.Errorf("failed to parse identities (SHD_KAH_018): %w", err)
	}

	if len(identities) == 0 {
		logger.Warn("No identity found for email", "email", email)
		return nil, fmt.Errorf("(SHD_0216105000) identity not found for email: %s", email)
	}

	// Return first match (email should be unique)
	userInfo := KratosIdentityToUserInfo(identities[0])
	logger.Info("Fetched Kratos identity by email", "email", email, "identity_id", userInfo.UserId)
	return userInfo, nil
}

// KratosGetUserInfoByAppToken fetches all Kratos identities that have a matching app token
// in their metadata_public field and returns them as []*ApiTypes.UserInfo.
// App tokens are stored in metadata_public as {"token_name": "token_value"} pairs.
// This function matches both the token name AND the token value.
// One token may match multiple users.
func KratosGetUserInfoByAppToken(
	logger ApiTypes.JimoLogger,
	tokenName string,
	token string) ([]*ApiTypes.UserInfo, error) {
	adminURL := getKratosAdminURL()
	ctx := context.Background()
	httpClient := &http.Client{Timeout: 15 * time.Second}

	// Step 1: List all identities
	reqURL := fmt.Sprintf("%s/admin/identities?per_page=1000", adminURL)
	req, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		logger.Error("Failed to create list identities request for app token search", "error", err, "token_name", tokenName)
		return nil, fmt.Errorf("failed to create request (SHD_KAH_050): %w", err)
	}
	req.Header.Set("Accept", "application/json")

	resp, err := httpClient.Do(req)
	if err != nil {
		logger.Error("Failed to list identities for app token search", "error", err, "token_name", tokenName)
		return nil, fmt.Errorf("failed to list identities (SHD_KAH_051): %w", err)
	}
	defer resp.Body.Close()

	body, _ := io.ReadAll(resp.Body)
	if resp.StatusCode != http.StatusOK {
		logger.Error("Kratos Admin API error listing identities for app token",
			"status", resp.StatusCode, "body", string(body), "token_name", tokenName)
		return nil, fmt.Errorf("kratos error listing identities (SHD_KAH_052): status %d", resp.StatusCode)
	}

	var identities []map[string]interface{}
	if err := json.Unmarshal(body, &identities); err != nil {
		logger.Error("Failed to parse identities response for app token search", "error", err, "token_name", tokenName)
		return nil, fmt.Errorf("failed to parse identities (SHD_KAH_053): %w", err)
	}

	// Step 2: Filter identities that have the matching app token name AND value in metadata_public
	matchedUsers := make([]*ApiTypes.UserInfo, 0)
	for _, identity := range identities {
		if metadataPublic, ok := identity["metadata_public"].(map[string]interface{}); ok {
			// Check if the tokenName exists in metadata_public
			if tokenValue, exists := metadataPublic[tokenName]; exists && tokenValue != nil {
				// Convert token value to string and check if it matches the provided token
				if tokenStr, ok := tokenValue.(string); ok && tokenStr == token {
					userInfo := KratosIdentityToUserInfo(identity)
					matchedUsers = append(matchedUsers, userInfo)
					logger.Info("Found identity with matching app token",
						"identity_id", userInfo.UserId, "email", userInfo.Email, "token_name", tokenName)
				}
			}
		}
	}

	if len(matchedUsers) == 0 {
		logger.Warn("No identities found with matching app token", "token_name", tokenName)
		return []*ApiTypes.UserInfo{}, nil // Return empty array instead of error
	}

	logger.Info("Found identities with matching app token", "token_name", tokenName, "count", len(matchedUsers))
	return matchedUsers, nil
}

// UpdateAppTokenByEmail updates or deletes an app token for a user identified by email.
// App tokens are stored in metadata_public as {"token_name": "xxx", "token": "xxx"}.
// If token is empty, the app token identified by tokenName is deleted.
// Returns an error if the user is not found or the update fails.
func UpdateAppTokenByEmail(logger ApiTypes.JimoLogger, email string, tokenName string, token string) error {
	// Step 1: Get the identity by email to retrieve the identity ID
	userInfo, err := KratosGetIdentityByEmail(logger, email)
	if err != nil {
		logger.Error("Failed to get identity by email for app token update",
			"error", err, "email", email, "token_name", tokenName)
		return fmt.Errorf("failed to get identity by email (SHD_KAH_040): %w", err)
	}

	// Step 2: Get the raw identity to access metadata_public
	rawIdentity, err := kratosGetRawIdentity(userInfo.UserId)
	if err != nil {
		logger.Error("Failed to get raw identity for app token update",
			"error", err, "identity_id", userInfo.UserId, "token_name", tokenName)
		return fmt.Errorf("failed to get raw identity (SHD_KAH_041): %w", err)
	}

	// Step 3: Extract existing metadata_public
	metadataPublic := make(map[string]interface{})
	if mp, ok := rawIdentity["metadata_public"].(map[string]interface{}); ok {
		// Copy existing metadata_public
		for k, v := range mp {
			metadataPublic[k] = v
		}
	}

	// Step 4: Update or delete the app token
	if token == "" {
		// Delete the app token if token is empty
		delete(metadataPublic, tokenName)
		logger.Info("Deleting app token from metadata_public",
			"email", email, "identity_id", userInfo.UserId, "token_name", tokenName)
	} else {
		// Update or add the app token
		metadataPublic[tokenName] = token
		logger.Info("Updating app token in metadata_public",
			"email", email, "identity_id", userInfo.UserId, "token_name", tokenName)
	}

	// Step 5: Update the identity using KratosUpdateIdentityWrapper
	err = KratosUpdateIdentityWrapper(logger, userInfo.UserId, nil, metadataPublic, nil)
	if err != nil {
		logger.Error("Failed to update identity with app token",
			"error", err, "identity_id", userInfo.UserId, "token_name", tokenName)
		return fmt.Errorf("failed to update identity with app token (SHD_KAH_042): %w", err)
	}

	logger.Info("Successfully updated app token",
		"email", email, "identity_id", userInfo.UserId, "token_name", tokenName, "is_delete", token == "")
	return nil
}

// kratosGetRawIdentity fetches the raw JSON identity from Kratos Admin API.
// Used internally by KratosUpdateIdentity for the GET-then-PUT pattern.
func kratosGetRawIdentity(identityID string) (map[string]interface{}, error) {
	adminURL := getKratosAdminURL()
	ctx := context.Background()
	httpClient := &http.Client{Timeout: 10 * time.Second}

	req, err := http.NewRequestWithContext(ctx, "GET",
		fmt.Sprintf("%s/admin/identities/%s", adminURL, identityID), nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request (SHD_KAH_020): %w", err)
	}
	req.Header.Set("Accept", "application/json")

	resp, err := httpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to get identity (SHD_KAH_021): %w", err)
	}
	defer resp.Body.Close()

	body, _ := io.ReadAll(resp.Body)
	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("kratos error (SHD_KAH_022): status %d, body: %s", resp.StatusCode, string(body))
	}

	var identity map[string]interface{}
	if err := json.Unmarshal(body, &identity); err != nil {
		return nil, fmt.Errorf("failed to parse identity (SHD_KAH_023): %w", err)
	}
	return identity, nil
}

// KratosUpdateIdentity updates a Kratos identity using the GET-then-PUT pattern.
// Only non-nil fields in the update struct are applied; all other fields are preserved.
func KratosUpdateIdentity(logger ApiTypes.JimoLogger, identityID string, update KratosIdentityUpdate) error {
	// Step 1: Fetch current identity
	current, err := kratosGetRawIdentity(identityID)
	if err != nil {
		logger.Error("Failed to fetch identity for update", "error", err, "identity_id", identityID)
		return err
	}

	// Step 2: Build update body, preserving existing fields
	updateBody := map[string]interface{}{
		"schema_id": current["schema_id"],
		"traits":    current["traits"],
	}

	// Preserve state (default)
	if state, ok := current["state"].(string); ok {
		updateBody["state"] = state
	} else {
		updateBody["state"] = "active"
	}

	// Preserve metadata_public
	existingMP := make(map[string]interface{})
	if mp, ok := current["metadata_public"].(map[string]interface{}); ok {
		for k, v := range mp {
			existingMP[k] = v
		}
	}

	// Preserve metadata_admin
	if ma, ok := current["metadata_admin"]; ok && ma != nil {
		updateBody["metadata_admin"] = ma
	}

	// Apply trait updates (merge into existing traits)
	if update.Traits != nil {
		existingTraits := make(map[string]interface{})
		if traits, ok := current["traits"].(map[string]interface{}); ok {
			for k, v := range traits {
				existingTraits[k] = v
			}
		}
		for k, v := range update.Traits {
			existingTraits[k] = v
		}
		updateBody["traits"] = existingTraits
	}

	// Apply metadata_public updates (merge into existing)
	if update.MetadataPublic != nil {
		for k, v := range update.MetadataPublic {
			existingMP[k] = v
		}
	}
	updateBody["metadata_public"] = existingMP

	// Apply state update
	if update.State != nil {
		updateBody["state"] = *update.State
	}

	// Step 3: PUT updated identity
	adminURL := getKratosAdminURL()
	ctx := context.Background()
	httpClient := &http.Client{Timeout: 10 * time.Second}

	updateJSON, err := json.Marshal(updateBody)
	if err != nil {
		logger.Error("Failed to marshal update body", "error", err, "identity_id", identityID)
		return fmt.Errorf("failed to marshal update (SHD_KAH_030): %w", err)
	}

	putReq, err := http.NewRequestWithContext(ctx, "PUT",
		fmt.Sprintf("%s/admin/identities/%s", adminURL, identityID),
		bytes.NewReader(updateJSON))
	if err != nil {
		logger.Error("Failed to create update request", "error", err, "identity_id", identityID)
		return fmt.Errorf("failed to create update request (SHD_KAH_031): %w", err)
	}
	putReq.Header.Set("Content-Type", "application/json")
	putReq.Header.Set("Accept", "application/json")

	putResp, err := httpClient.Do(putReq)
	if err != nil {
		logger.Error("Failed to update identity in Kratos", "error", err, "identity_id", identityID)
		return fmt.Errorf("failed to update identity (SHD_KAH_032): %w", err)
	}
	defer putResp.Body.Close()

	putBody, _ := io.ReadAll(putResp.Body)
	if putResp.StatusCode != http.StatusOK {
		logger.Error("Kratos Admin API error updating identity",
			"status", putResp.StatusCode, "body", string(putBody), "identity_id", identityID)
		return fmt.Errorf("kratos error updating identity (SHD_KAH_033): status %d, body: %s",
			putResp.StatusCode, string(putBody))
	}

	logger.Info("Updated Kratos identity", "identity_id", identityID)
	return nil
}

// KratosDeleteIdentitySessions deletes all sessions for a Kratos identity.
// Used when deactivating a user to force immediate logout.
func KratosDeleteIdentitySessions(logger ApiTypes.JimoLogger, identityID string) error {
	adminURL := getKratosAdminURL()
	ctx := context.Background()
	httpClient := &http.Client{Timeout: 10 * time.Second}

	req, err := http.NewRequestWithContext(ctx, "DELETE",
		fmt.Sprintf("%s/admin/identities/%s/sessions", adminURL, identityID), nil)
	if err != nil {
		logger.Error("Failed to create delete sessions request", "error", err, "identity_id", identityID)
		return fmt.Errorf("failed to create request (SHD_KAH_060): %w", err)
	}

	resp, err := httpClient.Do(req)
	if err != nil {
		logger.Error("Failed to delete sessions from Kratos", "error", err, "identity_id", identityID)
		return fmt.Errorf("failed to delete sessions (SHD_KAH_061): %w", err)
	}
	defer resp.Body.Close()

	// 204 No Content or 200 OK are both success responses
	if resp.StatusCode != http.StatusNoContent && resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(resp.Body)
		logger.Error("Kratos Admin API error deleting sessions",
			"status", resp.StatusCode, "body", string(body), "identity_id", identityID)
		return fmt.Errorf("kratos error deleting sessions (SHD_KAH_062): status %d", resp.StatusCode)
	}

	logger.Info("Deleted all sessions for identity", "identity_id", identityID)
	return nil
}

// KratosMarkUserVerified marks a user as verified by setting their identity state to "active".
// This is used for admin override or manual verification.
// With Kratos, email verification is normally handled by Kratos flows automatically.
func KratosMarkUserVerified(logger ApiTypes.JimoLogger, email string) error {
	// Get identity by email to find the identity ID
	userInfo, err := KratosGetIdentityByEmail(logger, email)
	if err != nil {
		logger.Error("Failed to get user by email for verification", "email", email, "error", err)
		return fmt.Errorf("failed to get user for verification (SHD_KAH_050): %w", err)
	}

	// Update identity state to "active"
	activeState := "active"
	err = KratosUpdateIdentity(logger, userInfo.UserId, KratosIdentityUpdate{
		State: &activeState,
	})
	if err != nil {
		logger.Error("Failed to mark user verified in Kratos", "email", email, "identity_id", userInfo.UserId, "error", err)
		return fmt.Errorf("failed to mark user verified (SHD_KAH_051): %w", err)
	}

	logger.Info("Marked user verified in Kratos", "email", email, "identity_id", userInfo.UserId)
	return nil
}

// KratosUpdatePassword updates a user's password in Kratos via the Admin API.
// This function:
//  1. Gets the identity by email
//  2. Fetches the current identity from Kratos
//  3. Updates the password via the credentials field
//
// Note: Password updates require the credentials field to be set, which is
// separate from the traits/metadata updates handled by KratosUpdateIdentity.
func KratosUpdatePassword(logger ApiTypes.JimoLogger, email string, plaintextPassword string) error {
	// Step 1: Get identity by email to find the identity ID
	userInfo, err := KratosGetIdentityByEmail(logger, email)
	if err != nil {
		logger.Error("Failed to get user by email for password update", "email", email, "error", err)
		return fmt.Errorf("failed to get user for password update (SHD_KAH_060): %w", err)
	}

	identityID := userInfo.UserId

	// Step 2: Fetch current identity to preserve all fields
	adminURL := getKratosAdminURL()
	ctx := context.Background()
	httpClient := &http.Client{Timeout: 10 * time.Second}

	getReq, err := http.NewRequestWithContext(ctx, "GET",
		fmt.Sprintf("%s/admin/identities/%s", adminURL, identityID), nil)
	if err != nil {
		logger.Error("Failed to create get identity request", "error", err, "identity_id", identityID)
		return fmt.Errorf("failed to create get request (SHD_KAH_061): %w", err)
	}
	getReq.Header.Set("Accept", "application/json")

	getResp, err := httpClient.Do(getReq)
	if err != nil {
		logger.Error("Failed to fetch identity from Kratos", "error", err, "identity_id", identityID)
		return fmt.Errorf("failed to fetch identity (SHD_KAH_062): %w", err)
	}
	defer getResp.Body.Close()

	getBody, _ := io.ReadAll(getResp.Body)
	if getResp.StatusCode != http.StatusOK {
		logger.Error("Kratos Admin API error fetching identity",
			"status", getResp.StatusCode, "body", string(getBody), "identity_id", identityID)
		return fmt.Errorf("kratos error fetching identity (SHD_KAH_063): status %d", getResp.StatusCode)
	}

	var currentIdentity map[string]interface{}
	if err := json.Unmarshal(getBody, &currentIdentity); err != nil {
		logger.Error("Failed to parse identity", "error", err, "identity_id", identityID)
		return fmt.Errorf("failed to parse identity (SHD_KAH_064): %w", err)
	}

	// Step 3: Update the identity with the new password
	updateBody := map[string]interface{}{
		"schema_id": currentIdentity["schema_id"],
		"state":     "active",
		"traits":    currentIdentity["traits"],
		"credentials": map[string]interface{}{
			"password": map[string]interface{}{
				"config": map[string]interface{}{
					"password": plaintextPassword,
				},
			},
		},
	}

	// Preserve metadata_public if present
	if mp, ok := currentIdentity["metadata_public"]; ok && mp != nil {
		updateBody["metadata_public"] = mp
	}
	// Preserve metadata_admin if present
	if ma, ok := currentIdentity["metadata_admin"]; ok && ma != nil {
		updateBody["metadata_admin"] = ma
	}

	updateJSON, err := json.Marshal(updateBody)
	if err != nil {
		logger.Error("Failed to marshal update body", "error", err, "identity_id", identityID)
		return fmt.Errorf("failed to marshal update (SHD_KAH_065): %w", err)
	}

	putReq, err := http.NewRequestWithContext(ctx, "PUT",
		fmt.Sprintf("%s/admin/identities/%s", adminURL, identityID),
		strings.NewReader(string(updateJSON)))
	if err != nil {
		logger.Error("Failed to create update request", "error", err, "identity_id", identityID)
		return fmt.Errorf("failed to create update request (SHD_KAH_066): %w", err)
	}
	putReq.Header.Set("Content-Type", "application/json")
	putReq.Header.Set("Accept", "application/json")

	putResp, err := httpClient.Do(putReq)
	if err != nil {
		logger.Error("Failed to update password in Kratos", "error", err, "identity_id", identityID)
		return fmt.Errorf("failed to update password (SHD_KAH_067): %w", err)
	}
	defer putResp.Body.Close()

	putBody, _ := io.ReadAll(putResp.Body)
	if putResp.StatusCode != http.StatusOK {
		logger.Error("Kratos Admin API error updating password",
			"status", putResp.StatusCode, "body", string(putBody), "identity_id", identityID)
		return fmt.Errorf("kratos error updating password (SHD_KAH_068): status %d, body: %s",
			putResp.StatusCode, string(putBody))
	}

	logger.Info("Password updated successfully in Kratos",
		"email", email, "identity_id", identityID)

	sysdatastores.AddActivityLog(ApiTypes.ActivityLogDef{
		ActivityName: ApiTypes.ActivityName_Auth,
		ActivityType: ApiTypes.ActivityType_Success,
		AppName:      ApiTypes.AppName_Auth,
		ModuleName:   ApiTypes.ModuleName_EmailAuth,
		ActivityMsg:  func() *string { s := fmt.Sprintf("Kratos password update success, email:%s", email); return &s }(),
		CallerLoc:    "SHD_KAH_069",
	})

	return nil
}

// KratosCreateIdentityWithPassword creates a new Kratos identity via the Admin API
// with password credentials, state "active", and email pre-verified.
// This bypasses the registration flow entirely  no verification email is sent.
// Returns the created identity as *ApiTypes.UserInfo.
func KratosCreateIdentityWithPassword(
	logger ApiTypes.JimoLogger,
	email, firstName, lastName, plaintextPassword string,
) (*ApiTypes.UserInfo, error) {
	adminURL := getKratosAdminURL()
	ctx := context.Background()
	httpClient := &http.Client{Timeout: 10 * time.Second}

	// Build the identity creation payload
	traits := map[string]interface{}{
		"email": email,
	}
	if firstName != "" || lastName != "" {
		traits["name"] = map[string]interface{}{
			"first": firstName,
			"last":  lastName,
		}
	}

	createBody := map[string]interface{}{
		"schema_id": "default",
		"traits":    traits,
		"state":     "active",
		"credentials": map[string]interface{}{
			"password": map[string]interface{}{
				"config": map[string]interface{}{
					"password": plaintextPassword,
				},
			},
		},
		"verifiable_addresses": []map[string]interface{}{
			{
				"value":    email,
				"via":      "email",
				"verified": true,
				"status":   "completed",
			},
		},
	}

	bodyJSON, err := json.Marshal(createBody)
	if err != nil {
		logger.Error("Failed to marshal identity creation body", "error", err, "email", email)
		return nil, fmt.Errorf("failed to marshal body (SHD_KAH_070): %w", err)
	}

	reqURL := fmt.Sprintf("%s/admin/identities", adminURL)
	req, err := http.NewRequestWithContext(ctx, "POST", reqURL, bytes.NewReader(bodyJSON))
	if err != nil {
		logger.Error("Failed to create identity request", "error", err, "email", email)
		return nil, fmt.Errorf("failed to create request (SHD_KAH_071): %w", err)
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept", "application/json")

	resp, err := httpClient.Do(req)
	if err != nil {
		logger.Error("Failed to create identity in Kratos", "error", err, "email", email)
		return nil, fmt.Errorf("failed to create identity (SHD_KAH_072): %w", err)
	}
	defer resp.Body.Close()

	respBody, _ := io.ReadAll(resp.Body)

	// 201 Created is the expected success status
	if resp.StatusCode != http.StatusCreated && resp.StatusCode != http.StatusOK {
		logger.Error("Kratos Admin API error creating identity",
			"status", resp.StatusCode, "body", string(respBody), "email", email)

		// 409 Conflict means identity with this email already exists
		if resp.StatusCode == http.StatusConflict {
			return nil, fmt.Errorf("an account with this email already exists (SHD_KAH_073)")
		}

		return nil, fmt.Errorf("kratos error creating identity (SHD_KAH_074): status %d, body: %s",
			resp.StatusCode, string(respBody))
	}

	var identity map[string]interface{}
	if err := json.Unmarshal(respBody, &identity); err != nil {
		logger.Error("Failed to parse created identity response", "error", err, "email", email)
		return nil, fmt.Errorf("failed to parse identity response (SHD_KAH_075): %w", err)
	}

	userInfo := KratosIdentityToUserInfo(identity)
	logger.Info("Created Kratos identity via Admin API (no verification email)",
		"identity_id", userInfo.UserId, "email", email)

	sysdatastores.AddActivityLog(ApiTypes.ActivityLogDef{
		ActivityName: ApiTypes.ActivityName_Auth,
		ActivityType: ApiTypes.ActivityType_SignupSuccess,
		AppName:      ApiTypes.AppName_Auth,
		ModuleName:   ApiTypes.ModuleName_EmailAuth,
		ActivityMsg: func() *string {
			s := fmt.Sprintf("Kratos identity created via Admin API (invite), email:%s, id:%s", email, userInfo.UserId)
			return &s
		}(),
		CallerLoc: "SHD_KAH_076",
	})

	return userInfo, nil
}

// KratosUpdateIdentityWrapper is a wrapper for KratosUpdateIdentity that matches the function pointer signature
// used in EchoFactory to avoid import cycles.
func KratosUpdateIdentityWrapper(
	logger ApiTypes.JimoLogger,
	identityID string,
	traits map[string]interface{},
	metadataPublic map[string]interface{},
	state *string) error {

	update := KratosIdentityUpdate{}

	if len(traits) > 0 {
		update.Traits = traits
	}
	if len(metadataPublic) > 0 {
		update.MetadataPublic = metadataPublic
	}
	if state != nil {
		update.State = state
	}

	return KratosUpdateIdentity(logger, identityID, update)
}
